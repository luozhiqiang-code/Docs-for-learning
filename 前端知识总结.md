# HTML

## 1.1 标签head、body、！doctype

!doctype标签：只是浏览器按照哪个版本来解析当前html。

html：根元素，一个HTML文档只有一个根元素。

head：包含所有头部元素的标签，不会对用户显示。可以声明文档的语言，视口大小，引入js文件，CSS文件，页面的icon等。

body：定义文档的主体，包含了文档的主要内容。

### 文件的引入方式

#### **引入css**

​	link 的使用

```
<link href="index.css" rel="stylesheet">
```

@import 的使用

```
<style type="text/css">
@import url(index.css);
</style>
```

两者的区别

1. 引入的内容不同，link除了可以引入css文件以外，还可以引入JavaScript，icon，等资源
2. 加载顺序不一样，link引入css在页面加载的时候同步加载，按顺序。而@import需要页面完全加载完成后开始加载
3. 兼容性不同，link是HTML标签，浏览器都支持，而@important是css2.1提出的新特性。
4. 对js的支持不同，link支持js控制DOM增加link来改变样式，而@important不能。

#### 关于link用href引入地址，script和img等标签用src

- src用于替换当前元素，是替换元素所有的属性，而link建立资源之间的链接，联系。
- 因为src指向的资源替换当前元素改变DOM结构，所以浏览器在解析到改元素时会暂停其它资源的下载和解析，知道加载解析完该资源。所以src指向的资源的加载和指向是同步的。比如为了防止阻塞，一般将js放最后
- herf指向的资源是并行下载和处理的，不会阻塞文档的处理，所以建议用link加载CSS。

## 1.2 H5新特性

**新增的特性**

- 新增选择器 document.querySelector、document.querySelectorAll ；
- 媒体播放的 video 和 audio 
- 本地存储 localStorage 和 sessionStorage 
- 语意化标签 article、footer、header、nav、section 
- 全双工通信协议 websocket 

**移除的元素**

- 纯表现的元素：font、u、big等
- 有负作用的标签：frame，frameset等

## 1.3 伪类和伪元素

**伪类：**如名字表示的一样，伪类的效果就像增加了一个虚拟的类，幽灵类。比如我想选择文档中的一些特定位置的元素，可以用伪类来选择，选择的效果和我为特定元素设置了类一样。伪类有结构伪类first-of-type、动态伪类active、UI状态伪类hover等。

**伪元素：**如名字一样，效果如同增加了虚拟的元素。用于创建一些不在DOM树中的元素，例如、首字母first-word、首行first-line、before、after。

html5规定伪类用：，伪元素用：：。在这之前都是：。

## 1.5 HTML5语义化

h5以前都是用div来实现各种部分和模块，div没有语义。

- 语义化标签有利于SEO。
- 更好的文档结构（即使没有css也能一目了然）。
- 无障碍访问（屏幕阅读器可以识别）。
- 更好的开发维护（代码可读，与css配合）。



​	![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121492395/44B73F2E744FF268279D16601DB2CBC8)

# CSS

## 1 继承

css中的继承，中实际应用的角度来说，是为了减少工作量，继承与否要符合日常的习惯。

比如，设置一个父元素的字体，按理来说后面的子元素也应该用同一字体，如果不是特殊情况，那么继承就减轻了一层层设置字体的操作了；

## 2 CSS预处理工具

利用预处理器的语法可以生产CSS文件，提高效率。

比如预处理器可以将项目中常用的属性值，比如颜色，长度等设置变量名，用变量名编写属性值。类似于c语言中的宏定义。 

## 3 行内元素和块级元素

**行内元素：**当一行没有填满时，行内元素都在同一行，不会另起一行。行内元素的高度和宽度是不可控的，由内容决定。水平方向上可以设置margin、padding，垂直方向上设置后对周围元素无影响。

**块级元素：**每个块级元素另起一行，在纵向堆叠，会计元素的高度宽度（默认100%），边距，填充都是可控的。块级元素可以包含块级元素和行内元素；

**转换：**

- display：inlie
- display：block
- display：inline-block

## 4 盒模型

**概念：**盒模型用来描述元素的大小和位置信息，盒模型有标准盒模型和IE盒模型。

盒模型包含最外层margin表示盒子与周围元素的距离，然后是边界border，然后是表示内容与盒子的距离padding，然后是内容content；

###  标准盒模型

width、height表示content的。

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646122749913/F0AB2FF8B5108D122FBB2FA6C6590556)

##  IE盒模型

width、height表示可见宽度和高度，即content+padding+border。

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646122760914/EA16C3388EFD2F9E6CD930E8B7B99CBB)

### 2.4.3 设置方法

（标准）box-sizing：content-box；

（IE）box-sizing：border-box；

获得盒子的宽高：window.getComputedStyle(dom).width/height

## 5 BFC

### 什么是BFC

BFC全称 Block Formatting Context 即`块级格式上下文`，简单的说，BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界

**创建方式：**

- 浮动属性float
- 定位属性position：absolute、fixed，relative，static等
- 行内快inline-block
- 表格单元diaplay: table这类属性table-cell、table-caption
- 弹性盒子：display：flex，inline-flex
- overflow：非visible（wrap）

### BFC的渲染规则是什么

- BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界
- 计算BFC的高度时，浮动子元素也参与计算（即内部有浮动元素时也不会发生高度塌陷）
- BFC的区域不会与float的元素区域重叠
- BFC内部的元素会在垂直方向上放置
- BFC内部两个相邻元素的margin会发生重叠

###  BFC的应用场景

- **清除浮动**：BFC内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷
- **避免某元素被浮动元素覆盖**：BFC的区域不会与浮动元素的区域重叠
- **阻止外边距重叠**：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠
- 创建各种自适应布局：比如圣杯布局，双飞翼布局，自适应两三栏布局。

## 6 行内格式上下文

**概念：**内部的环境表现为行内格式。

**布局规则**：

- 内部的box会在水平方向一个一个堆叠。
- box之间只有水平方向的边距、边框、填充有效果。
- 对齐方式：以底部、顶部、基线对其。

### 7 层叠上下文

元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。

**触发条件**

- 根层叠上下文(`html`)
- `position`
- css3属性
  - `flex`
  - `transform`
  - `opacity`
  - `filter`
  - `will-change`
  - `webkit-overflow-scrolling`

**层叠等级：层叠上下文在z轴上的排序**

- 在同一层叠上下文中，层叠等级才有意义

- `z-index`的优先级最高

  <img src="https://s.poetries.work/gitee/2020/09/111.png" alt="img" style="zoom: 33%;" />

  

## 2.6 样式优先级

**样式分类三类：**

- 行间样式（在每个标签内部style属性设置）
- 内联样式（在head中style标签中写的样式）
- 外部样式（在head中，通过link标签引入的外部样式）



**选择器类型:**

- id选择器（#id)
- class选择器 (.class)
- 标签选择器 (p)
- 属性选择器 (class='className')
- 伪类选择器 （：active）
- 伪元素选择器（：first-line)
- 关系选择器（> ~+)



**权重：**

- 第一级：内联样式（1000）
- 第二级：id选择器（100）
- 第三级：类、伪类、属性（0010）
- 第四级：元素、伪元素（0001）
- 第0级别：关系选择器（0000）
- 无级别：继承的样式



**比较规则：**

1. ！important标记：！important比没有的权重高

2. 来源：读者的！important > 创作者的！important  > 创作者 > 读者 > 用户代理
3. 权重：按计算值
4. 排序位置：后声明的重要

## 2.7 盒子塌陷

定义：盒子内部的元素跑到外面去了。

原因：父元素没有足够大小，而子元素设置了浮动，从而脱离了标准文档流。

**解决办法**

1. 最简单的方法就是把盒子的大小写死。
2. 给父元素设置overflow。
3. 给父盒子添加border。

## 2.8 min-width/max-width 和 min-height/max-height 属性间的覆盖规则？

​	**参考答案**：

1. ​		max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。 
2. ​		min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候； 

## 2.9 浏览器是怎样解析CSS选择器的？

从右往左开始解析，如果从左往右开始解析发现不匹配规则的时候还要回溯。而从右往左会逐步缩小范围，效率更高

## 2.10 浮动

浮动并不是为布局而生的，浮动是用于排版的，报纸文章中的图片就是浮动排版。

float:left\right\none;

浮动的元素不管原来是何表现，浮动后变为块级元素。

### 清除浮动的方法

1. 在浮动元素后面添加 `clear:both`的空 `div` 元素

```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
    <div style="clear:both"></div>
</div>
```

1. 给父元素添加 `overflow:hidden` 或者 `auto` 样式，触发`BFC`

```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
</div>
.container{
    width: 300px;
    background-color: #aaa;
    overflow:hidden;
    zoom:1;   /*IE6*/
}
```

1. 使用伪元素，也是在元素末尾添加一个点并带有 `clear: both` 属性的元素实现的。

```html
<div class="container clearfix">
    <div class="left"></div>
    <div class="right"></div>
</div>
.clearfix{
    zoom: 1; /*IE6*/
}
.clearfix:after{
    content: ".";
    height: 0;
    clear: both;
    display: block;
    visibility: hidden;
}
```

> 推荐使用第三种方法，不会在页面新增div，文档结构更加清晰

## 2.11 定位

position: static\relative\sticky\absolute\fixed.

### 绝对定位

1. 子绝父相
2. 子绝，父为最近的非static。如果没有，则将页面第一屏作为初始定位块。

### 固定定位

将要定位的元素设置为fixed即可，不需要设定父。容纳块为视区，固定元素完全脱离标准文档流。

### 相对定位

相对定位的容纳块必须为static。

### 粘滞定位

设置为sticky的元素，偏移属性用来定义相对容纳块的粘滞定位移动区域。

## 2.12 弹性盒布局

**容器属性:**

flex-direction: row row-reverse column column-reverse

flex-wrap: nowarp warp wrap-reverse



justify-content定义主轴方向上各个元素的摆放，每一行都会起作用。

justify-content：flex-start flex-end center space-between space-around space-evenly



align-items定义垂轴方向上各个元素的对齐，是每一行在列的方向上对齐。

align-items: flex-start flex-end center baseline stretch

![img](https://pics7.baidu.com/feed/95eef01f3a292df5911650478809756935a87348.png?token=3575918b3ea1cec7625f733826517ef5)

align-content定义垂直方向上所有元素当成一个整体。和content有关的实际上都是如何将空间分配到元素周围。

align-content: flex-start flex-end center space-between space-around space-evenly stretch

![img](https://pics4.baidu.com/feed/810a19d8bc3eb13541a55ab29d2681dafd1f441e.png?token=546bb54b10adc387918b575f203fd2da)

**元素属性：**

弹性框中的元素都是弹性元素，文本节点也是，当文本不为空的时候（匿名弹性元素）

flex: flex-grow flex-shrink flex basis



flex-grow设置增长因子，不能为复数，用来当做份数的，除以增长因子的总和。

如果设置flex-basis为0，则按flex-grow比例分所有的宽度，如果设置flex-basis为auto，则分配最小内容宽度后再将空间按比例分。



flex-shrink设置缩减因子，缩减因子为0的时候，内容不换行，不缩减。缩减因子为正数时，会导致换行缩减。核心原则是内容至上，不能缩的时候不缩小。在满足flex-basis、width等基本条件下载缩小。



flex-basis: content 长度值

content: 设置了宽度则以宽度为基准，否则以内容为主。

min-width > flex-basis > width

align-self是单个元素的设置

order：整数

设置元素的排列顺序，默认全部是0。



## 2.13 栅格布局

**容器属性：**

- grid-template-rows
- grid-template-columns
- grid-template-areas
- grid-auto-flow
- grid-row-gap
- grud-column-gap
- align-items 
- justify-items

**元素属性：**

- grid-row-start
- grid-row-end
- grid-column-start
-  grid-column-end
- grid-area

## 29 stylus/sass/less区别

- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性
- `Scss`和`LESS`语法较为严谨，`LESS`要求一定要使用大括号“{}”，`Scss`和`Stylus`可以通过缩进表示层次与嵌套关系
- `Scss`无全局变量的概念，`LESS`和`Stylus`有类似于其它语言的作用域概念
- `Sass`是基于`Ruby`语言的，而`LESS`和`Stylus`可以基于`NodeJS` `NPM`下载相应库后进行编译；

## transition于animation区别

1. Transition 强调过渡; Animation 强调流程与控制 。


2. 两者的控制粒度不一样
   1. 某种程度上, transition 更加粗一点, 比如过渡的速度进行了封装, 可以控制是匀速改变还是贝塞尔曲线之类的。
   2. animation 提供的 keyframe 方法, 可以让你手动去指定每个阶段的属性; 此外 animation 还封装了循环次数, 动画延迟等功能, 更加自由和强大。

3. 动画状态: 
   1. CSS的 transition 只有两个状态:开始状态 和 结束状态 。
   2. animation 可能是多个状态, 有帧的概念 。
   
4. 动画触发方式:
   1. CSS的transition需要借助别的方式来触发, 比如CSS的状态选择器（如:hover）或 借助JavaScript来触发 。
   2. animation 不但可以使用上面的方式触发, 更重要的是可以自动触发 。
   
5. animation 控制动效上要比 transition 强，因为它具备一些控制动效的属性，比如“播放次数”、“播放方向”、“播放状态”等。

6. 动画实现的范围:
   1. transition 是有一定限制的, 并不是所有 CSS 的属性都具有过渡效果 。
   2. 另外相比而言, CSS 的 animation 要比 transition 强大的多, 几乎所有的 css 属性都可以实现动画效果。
   3. 这也是为什么使用 animation 制作 Web 动画的场景更多 。
   
7. 动画实现方式
   1. CSS 的 animation 是离不开 @keyframes 的，换句话说，我们需要先使用 @keyframes 来注册一个动画效果，即帧来描述动画效果。当然，只注册也不见得有效果，还是需要使用 animation-name 属性引用 @keyframes 注册好的动画效果。


"注意": CSS transform 也是用来制作动效的，这个说法有点偏颇，CSS transform 只不过提供了一些函数，可以做不同的变换，这些函数运用于 CSS 的 transition 或 @keyframes 中能得到一些不同的效果，特别是配上时间，缓动函数之类的，效果会更佳。因此也被识认为是动效中不可或缺。其实在 animation 中，可以发挥你的想象，使用 CSS 中任意属性，实现一些有创意的动效。

# JavaScript

## 3.1 let const var

**var**:

1. 声明变量为赋值，或者未声明的变量为undefined
2. 作用域为函数作用域，只要在方法内定义变量，整个方法内都可以调用变量，比如if语句中定义的变量，即使没有进入语句，通过函数变量提升，内部都可以使用。

**let：**

1. 块级作用域，以分号为代码块。定义之后才能使用，定义之前为零时死区，使用会报错。
2. 重复声明会报错。

**const：**

1. 定义常量，作用域和let一样，知识必须初始化，而且后面出现的代码不能再修改常量的值。
2. const实际保证的不是变量的值不得改动，而是变量指向的那个内存地址不能动（指向一个对象，对象是可以修改的，只是不能指向另外的对象了）。

**变量提升**：JavaScript会在编译阶段，检测所有的变量和函数声明，将它们添加到内存中，所以这些函数和变量在被声明的代码块之前就可以被使用了。

## 错误类型

### Error

`Error`是最基本的错误类型，其他的错误类型都继承自该类型。因此，所有错误的类型共享了一组相同的属性。 这个类型的错误很少见。一般使用开发人员自定义抛出的错误。



```jsx
new Error([message[,fileName[,lineNumber]]])，
//第一个参数表示错误提示信息，第二个是文件名，第三个是行号。
```

![img](https:////upload-images.jianshu.io/upload_images/10024246-20c28a74c1b5b06f.png?imageMogr2/auto-orient/strip|imageView2/2/w/901/format/webp)

### InternalError

`InternalError`类型的错误会在底层JavaScript引擎抛出异常时由浏览器抛出.例如,递归过多导致了栈溢出.这类型并不是代码中通常要处理的错误,如果真的发生了这种错误,很可能代码哪里弄错了或者有危险.



```cpp
 "InternalError: too much recursion"//（内部错误：递归过深）。
```

### EvalError

`EvalError`类型错误会在使用`eval()`函数发生异常时抛出evalError错误.`ECMA-262`规定,'如果eval属性没有被直接调用(就是没有将其名称作为一个Identifier(标识符),也就是`CallExpression`中的`MemberExpression`).
 基本上,只要不把`eval()`当成函数调用就会报错.
 不同浏览器抛出的错误会有差异,但很少会这么使用,所以平时不常见

![img](https:////upload-images.jianshu.io/upload_images/10024246-69b47d7ffa9871e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/611/format/webp)



> `需要注意的是：ES5以上的JavaScript中已经不再抛出该错误，但依然可以通过new关键字来自定义该类型的错误提示。

### RangeError

这个错误会在数值超出相应范围时触发。比如使用new Array()的时候传递一个负数或者是超过数组最大长度（4,294,967,295）的数，比如Number.MAX_VALUE，Number.MIN_VALUE。注意递归爆炸也有这个错误。



![img](https:////upload-images.jianshu.io/upload_images/10024246-9993bf53bcaa6b9f.png?imageMogr2/auto-orient/strip|imageView2/2/w/522/format/webp)

### ReferenceError

这个错误一般就是出现在变量找不到的情况，比如：



![img](https:////upload-images.jianshu.io/upload_images/10024246-6df0a918531ca685.png?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

### SyntaxError

SyntaxError 主要在语法编写出现问题时发生。



```csharp
// 1. Syntax Error: 语法错误
// 1.1 变量名不符合规范
var 1       // Uncaught SyntaxError: Unexpected number
var 1a       // Uncaught SyntaxError: Invalid or unexpected token
// 1.2 给关键字赋值
function = 5     // Uncaught SyntaxError: Unexpected token =
```

### TypeError

这个错误在JavaScript中是经常遇到的，不管是初学者还是老手。在变量中保存着以外的类型时，或者在访问不存在的方法时。都会导致这种错误。但是归根结底还是由于在执行特定于类型的操作时，变量的类型并不符合要求所致。

> 在给函数传参前没有验证的情况下,错误频繁发生.

![img](https:////upload-images.jianshu.io/upload_images/10024246-d231b1e702b08e27.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)

### URIError

`URIError`只会在使用`encodeURL()`或`decodeURL()`但传入了格式错误的URL时发生,但非常罕见,因为上面两个函数非常稳健.



作者：涅槃快乐是金
链接：https://www.jianshu.com/p/4007ba832046
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 3.2 数据类型 

**ES5：**Number，String， Boolean，undefined，Null

**ES6：**Symbol，Bigint

引用数据类型：Object、Function、Array、Date、RegExp、基本包装类型（Boolean、Number、String）、单体内置对象。

**各自的存储方式：**

1. 基本数据类型直接存储在栈中，占用空间小，大小固定，属于频繁使用的数据。（栈是存储基本类型值和执行代码的空间）
2. 引用数据类型存储在堆内存中，占据空间大，大小不固定，引用数据类型在栈中存储了指针，指针指向堆内存中的其实地址。

## **2. 数据类型检测**

**（1）typeof**

> typeof 对于原始类型来说，除了 null 都可以显示正确的类型

```js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object
```

> ```
> typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 `instanceof
> ```

**（2）instanceof**

> ```
> instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype
> ```

```js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false  
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true    
// console.log(undefined instanceof Undefined);
// console.log(null instanceof Null);
```

- `instanceof` 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；
- 而 `typeof` 也存在弊端，它虽然可以判断基础数据类型（`null` 除外），但是引用数据类型中，除了 `function` 类型以外，其他的也无法判断

```js
// 我们也可以试着实现一下 instanceof
function instanceof(left, right) {
    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
    	if (left === null)
    		return false
    	if (prototype === left)
    		return true
    	left = left.__proto__
    }
}
```

**（3）constructor**

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
```

> 这里有一个坑，如果我创建一个对象，更改它的原型，`constructor`就会变得不可靠了

```js
function Fn(){};
 
Fn.prototype=new Array();
 
var f=new Fn();
 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true 
```

**（4）Object.prototype.toString.call()**

> `toString()` 是 `Object` 的原型方法，调用该方法，可以统一返回格式为 `“[object Xxx]”` 的字符串，其中 `Xxx` 就是对象的类型。对于 `Object` 对象，直接调用 `toString()` 就能返回 `[object Object]`；而对于其他对象，则需要通过 `call` 来调用，才能返回正确的类型信息。我们来看一下代码。

```js
Object.prototype.toString({})       // "[object Object]"
Object.prototype.toString.call({})  // 同上结果，加上call也ok
Object.prototype.toString.call(1)    // "[object Number]"
Object.prototype.toString.call('1')  // "[object String]"
Object.prototype.toString.call(true)  // "[object Boolean]"
Object.prototype.toString.call(function(){})  // "[object Function]"
Object.prototype.toString.call(null)   //"[object Null]"
Object.prototype.toString.call(undefined) //"[object Undefined]"
Object.prototype.toString.call(/123/g)    //"[object RegExp]"
Object.prototype.toString.call(new Date()) //"[object Date]"
Object.prototype.toString.call([])       //"[object Array]"
Object.prototype.toString.call(document)  //"[object HTMLDocument]"
Object.prototype.toString.call(window)   //"[object Window]"

// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。
```

> 实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下

```js
function getType(obj){
  let type  = typeof obj;
  if (type !== "object") {    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type;
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');  // 注意正则中间有个空格
}
/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */
getType([])     // "Array" typeof []是object，因此toString返回
getType('123')  // "string" typeof 直接返回
getType(window) // "Window" toString返回
getType(null)   // "Null"首字母大写，typeof null是object，需toString来判断
getType(undefined)   // "undefined" typeof 直接返回
getType()            // "undefined" typeof 直接返回
getType(function(){}) // "function" typeof能判断，因此首字母小写
getType(/123/g)      //"RegExp" toString返回
```

**小结**

- ```
  typeof
  ```

  - 直接在计算机底层基于数据类型的值（二进制）进行检测
  - `typeof null`为`object` 原因是对象存在在计算机中，都是以`000`开始的二进制存储，所以检测出来的结果是对象
  - `typeof` 普通对象/数组对象/正则对象/日期对象 都是`object`
  - `typeof NaN === 'number'`

- ```
  instanceof
  ```

  - 检测当前实例是否属于这个类的
  - 底层机制：只要当前类出现在实例的原型上，结果都是true
  - 不能检测基本数据类型

- ```
  constructor
  ```

  - 支持基本类型
  - constructor可以随便改，也不准

- ```
  Object.prototype.toString.call([val])
  ```

  - 返回当前实例所属类信息

> 判断 `Target` 的类型，单单用 `typeof` 并无法完全满足，这其实并不是 `bug`，本质原因是 `JS` 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:

- 基本类型(`null`): 使用 `String(null)`
- 基本类型(`string / number / boolean / undefined`) + `function`: - 直接使用 `typeof`即可
- 其余引用类型(`Array / Date / RegExp Error`): 调用`toString`后根据`[object XXX]`进行判断

## 3.3 Object.assign的理解

​	**参考答案：**

​	作用：Object.assign可以实现对象的合并。

​	语法：Object.assign(target, ...sources)

​	**解析**：

1. ​		Object.assign会将source里面的可枚举属性复制到target，如果和target的已有属性重名，则会覆盖。 
2. ​		后续的source会覆盖前面的source的同名属性。 
3. ​		Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。 

## 3.4 constructor的理解

**参考答案：**

创建的每个对象都有一个prototype属性，该属性指向一个原型对象。原型对象有一个constructor属性，该属性指向原型对象所在函数。

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121650388/2B869BED138922220E1DC0C5C1B898EE)

## 3.5 map 和 forEach 的区别

​	**参考答案：**

​	相同点：

1. ​			都是循环遍历数组中的每一项 	
2. ​			每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组） 	
3. ​			匿名函数中的this都是指向window 	
4. ​			只能遍历数组 	

​	不同点：

1. ​			map()会分配内存空间存储新数组并返回，forEach()不会返回数据。 	
2. ​			forEach()允许callback更改原始数组的元素。map()返回新的数组。 	

```
const array1 = [1, 4, 9, 16];

// pass a function to map
const map1 = array1.map(x => x * 2);

console.log(map1);
// expected output: Array [2, 8, 18, 32]
```

```
const array1 = ['a', 'b', 'c'];

array1.forEach(element => console.log(element));

// expected output: "a"
// expected output: "b"
// expected output: "c"

```

## 3.6 for of 可以遍历哪些对象

​	**参考答案：**

​	for..of..: 它是es6新增的一个遍历方法，但**只限于迭代器(iterator)**, 所以普通的对象用for..of遍历
 是会报错的。

​	可迭代的对象：包括Array, Map, Set, String, TypedArray, arguments对象等等

## 3.7 JS静态类型检查

静态语义的类型检查发生在编译阶段，即使检查出误差，直到解决完错误才能编译完成。

而动态语义的类型检查发生在运行阶段，只有执行时才能发现错误，因此即使代码中包含了错误也能通过编译。

**检查方法：**

使用JavaScript的超集Typescript，Typescript很想静态类型语言。

**静态语言优势：**

- 编译阶段就能及早发现bug
- 减少了错误处理
- 减少了单元测试
- 将数据与行为分离力

## 3.8 indexOf()

```
arr.indexOf(searchElement[, fromIndex])
```

```
const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

console.log(beasts.indexOf('bison'));
// expected output: 1

// start from index 2
console.log(beasts.indexOf('bison', 2));
// expected output: 4

console.log(beasts.indexOf('giraffe'));
```

```
const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

console.log(beasts.indexOf('bison'));
// expected output: 1

// start from index 2
console.log(beasts.indexOf('bison', 2));
// expected output: 4

console.log(beasts.indexOf('giraffe'));
// expected output: -1

```

## 3.9 iframe

**优点：**

1. 原封不动嵌入网页，便于拓展（bilibili）
2. 网页如果为了统一风格，可以把不变的头部和尾部版本写成一个页面。用iframe嵌套，实现代码复用。

**缺点：**

1. 阻塞主页面的onload事假
2. 和主页面共享连接池，而连接池有限，会影响页面的加载效率
3. 多个iframe嵌套会有多个滚动条，易用性不好。
4. 代码复杂，不利于SEO
5. 移动设备显示不了



## 3.10  Dva 数据流向

dva 首先是一个基于 [redux](https://github.com/reduxjs/redux)[ ](https://github.com/reduxjs/redux) 和 [redux-saga](https://github.com/redux-saga/redux-saga)[ ](https://github.com/redux-saga/redux-saga) 的数据流方案，然后为了简化开发体验，dva 还额外内置了 [react-router](https://github.com/ReactTraining/react-router)[ ](https://github.com/ReactTraining/react-router) 和 [fetch](https://github.com/github/fetch)[ ](https://github.com/github/fetch)

，所以也可以理解为一个轻量级的应用框架。

数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 `dispatch` 发起一个 action，如果是同步行为会直接通过 `Reducers` 改变 `State` ，如果是异步行为（副作用）会先触发 `Effects` 然后流向 `Reducers` 最终改变 `State`，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致（也是来自于开源社区）。

![img](https://zos.alipayobjects.com/rmsportal/PPrerEAKbIoDZYr.png)

## 3.11 Map、Array、Object的区别

效率：Map根据hashcode的算出index，数组利用二分法查找，前者效率更高。

空间：Map需要的空间更大，消耗的内存更多。

在没有Map之前，都是用Object模拟map。

- 相比于Object，Map键可以是任何类型，而Object只能作为属性名的类型（string，symbol）。
- map的键是有顺序的，Object键的顺序不能保证的，在ES6以后可以通过字符串键名的对象会按照插入的顺序。
- Map是可以迭代的
- 增删改查效率更高，优化过的

## 3.12 javascript中arguments相关的问题

​	**参考答案：**

​	**arguments**

​	在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js会把所传的参数全部存到一个叫arguments的对象里面。它是一个**类数组数据**

​	**由来**

​	Javascrip中每个函数都会有一个Arguments对象实例arguments，引用着函数的实参。它是寄生在js函数当中的，不能显式创建，arguments对象只有函数开始时才可用

​	**作用**

​	有了arguments这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过arguments为函数加入参数

## 3.13 instanceOf 原理，手动实现 function isInstanceOf (child, Parent)

​	**参考答案**：

​	instanceof主要作用就是判断一个实例是否属于某种类型

```
let person = function(){

}
let no = new person()
no instanceof person//true
```

instanceOf 原理

```
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
        if (leftVaule === null) {
            return false;    
        }
        if (leftVaule === rightProto) {
            return true;    
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
```

​	![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121650388/2B869BED138922220E1DC0C5C1B898EE)

## 3.18 数组去重

**ES6**

```
functio unique(arr){
 return Array.from(new Set(arr))
}
```

```
function unique(arr){
    return arr.filter(function(item,index,arr){
        return arr.indexOf(item,0) === index;
    });
}
```

**ES5**

```
function unique(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1);
        j--;
      }
    }
  }

  return arr;
}
```

## 3.19 null 和 undefined

没有声明或者声明没有赋值的变量是undefined，表示一种初始状态

null表示空值，语义是一个对象被重置为空对象。一般回收内存时，会把对象设置为null，便接触了栈中变量对其的指向。在内存中的表示就是栈中没有变量指向堆中的内存对象。	![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121680358/0B3EF648CF963F2F1CFB70DE3D6350F4)

## 3.20 数组和伪（类）数组

数组是一个特殊对象：

- length属性随着数组中的数量变化
- 设置length可以截断数组
- 从Array.prototype继承了方法，属性为Array

类数组是简单对象，与数组的原型关系不同

- 拥有length属性，属性必须为非负整数
- 构造函数是Object
- arguments就是类数组
- DOM方法返回的也是

类数组转换为数组

Array.from()

Array.prototype.slice.call()

```
let al1 = {
    length: 4,
    0: 0,
    1: 1,
    3: 3,
    4: 4,
    5: 5,
};
console.log(Array.from(al1)) // [0, 1, undefined, 3]
console.log(Array.prototype.slice.call(al2)); //[0, 1, empty × 2]
```

为类数组添加数组的方法

```
  let arrayLike2 = {
    2: 3,
    3: 4,
    length: 2,
    push: Array.prototype.push
  }

  // push 操作的是索引值为 length 的位置
  arrayLike2.push(1);
  console.log(arrayLike2); // {2: 1, 3: 4, length: 3, push: ƒ}
  arrayLike2.push(2);
  console.log(arrayLike2); // {2: 1, 3: 2, length: 4, push: ƒ}

```

## 3.21 Set 和 Map

**Set**

1. 成员不能重复
2. 只有键名，没有键值，可以理解成不重复的数组
3. 可以遍历，有add、 delete、has、clear

**WeakSet**

1. 成员必须是对象
2. 成员都是弱引用，随时可以消失。可以用来保存DOM节点，不会造成内存泄漏
3. 不能遍历，方法与Set相同

**Map**

1. 本质是是键值对的集合，所以成员也不能重复
2. 可以遍历，方法有set、get、has、delete

**WeakMap**

1. 只能接受对象作为键名字
2. 键名指向的对象是弱引用，不计入垃圾回收机制
3. 不能遍历，方法与Map同。

## 3.22 内存泄漏

内存泄漏值得是分配出去的内存无法被垃圾回收机制正常回收.

JS中，基本变量和函数是放在栈内存中的，由系统自动分配内存。而对象等类型是由程序员手动分配内存的，比如C中用 malloc, js 中用new关键字来开辟空间。

分配的对象内存地址由栈中的变量指向，如果某个对象一直被变量引用着，在用完后没有得到释放就会造成内存泄漏。

出现内存泄漏的情况

1. 意外的全局变量
2. 闭包
3. 未清空的定时器
4. 未销毁的事件监听
5. DOM引用

## 3.23 JS执行机制

```JavaScript
// 今日头条面试题

async function async1() {

  console.log('async1 start')

  await async2()

  console.log('async1 end')

}

async function async2() {

  console.log('async2')

}

console.log('script start')

setTimeout(function () {

  console.log('settimeout')

})

async1()

new Promise(function (resolve) {

  console.log('promise1')

  resolve()

}).then(function () {

  console.log('promise2')

})

console.log('script end')

```

## 3.24 Json与xml

XMl是一种可扩展标记语言，可以用来传输和存储（表示）数据。

Json是一种轻量的数据格式，最早的浏览器是用XML来表示数据的，但是用XML来表示数据需要大量的标记，效率不够高，占用内存大。

而浏览器用js作为脚本语言，所以选择JS的对象表示，来表示数据，非常简洁，操作也方便，后面随着B\S模式的发展，json数据格式成了前后端通用的。

区别：

1. 数据体积不同，一个轻量级，一个重量级
2. 数据传输不同，因为数据体积的差异导致传输效率的差异
3. 数据交互，js是JavaScript的子集，数据交互更方便，容易解析
4. 数据描述，XML的数据描述性更好，Jason只有几种基本的数据类型
5. 用途，现在来说，json常用于数据交互，xml用于配置文件，比如java做后端，很多配置文件都是xml。

## 3.25 JS判断变量类型

typeof关键字：检测当前变量是否是Number、String、Boolean、Undefined、Null

```
typeof 37 === 'number';
```

instanceof：检测当前对象是否是某个对象的实例

```
object instanceof constructor
```

```
o instanceof C
```

## 3.26 Math.min()

```
var min = Math.min();
max = Math.max();
console.log(min < max);
// false
```

- ​				Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。 		
- ​				而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false 		

## 3.27 delete

```javascript
var company = {
    address: 'beijing'
}
var yideng = Object.create(company);
delete yideng.address
console.log(yideng.address);
// beijing
```

**`Object.create()`**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。

所以对象yideng的address是company的，而非自己的，所以删除不了，只是把自己为定义的属性删除了一次。

```
var company = {
    address: 'beijing'
}
var yideng = Object.create(company);
yideng.address = 'ton';//将原型对象上的属性覆盖了
console.log(yideng.address);
delete yideng.address
console.log(yideng.address);
// beijing
```

 **`delete` 操作符**用于删除对象的某个属性；

1. 与通常的看法不同，delete操作符与直接释放内存无关，内管管理是通过断开引用间接完成的，所以delete是断开引用。
2. 如果删除的属性不存在，则delete不起作用，返回true
3. delete只能删除对象自身的属性，如果一个对象的属性与原型链上属性同名字，则只删除自身的。
4. delete 不能删除全局作用域中的函数，可以删除对象中的函数。
5. delete不删除用let，const声明的属性，在他们的作用域总。
6. delete不能删除不可配置的属性，例如Math，Array，Object内置对象的属性。

## 3.28 this

JS中的this可以理解为执行环境，调用对象。

当函数作为对象的方法调用时，函数中的 this 就是该对象； 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window； 嵌套函数中的 this 不会继承外层函数的 this 值。 最后，我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。

### call、apply、bind

![img](https://s.poetries.work/gitee/2019/11/1.png)

作用：可以改变函数内部的this指向，从而使得函数的执行环境发生改变。

```
function.call(thisArg, arg1, arg2, ...)
```

```
func.apply(thisArg, [argsArray])
```

```
function.bind(thisArg[, arg1[, arg2[, ...]]])
```

**区别：**

1. call和apply会调用函数，而bind不会调用函数，bind只改变this对象的指向
2. call得穿多个参数，apply可以穿参数数组
3. 应用场景：call常用作继承，apply因为可以穿参数数组，所以经常被用来做与数组相关的事，比如求数组的最值。bind只改变this的特点使得经常被用于需要绑定this的地方，比如定时器内部的this，匿名函数的this，类的构造器中绑定方法的this。

### 普通函数、匿名函数、剪头函数

**普通函数的this指向调用的对象**

```
        let getThis = function () {
            console.log(this);
        }

        let obj={
            name:"Jack",
            getThis:function(){
                console.log(this);
            }
        }
        //getThis()方法是由window在全局作用域中调用的，所以this指向调用该方法的对象，即window
        getThis();//window
        //此处的getThis()方法是obj这个对象调用的，所以this指向obj
        obj.getThis();//obj
```

**匿名函数的this指向全局对象window而非调用的对象**

```JavaScript
        let obj = {
            getThis: function () {
                return function () {
                    console.log(this);
                }
            }
        }
        obj.getThis()(); //window
        
               let obj = {
            getThis: function () {
            //提前保存this指向
                let _this=this//利用中间变量将外部的this传入到匿名函数中。
                return function () {
                    console.log(_this);
                }
            }
        }
        obj.getThis()(); //obj
```

### 箭头函数

**箭头函数的this**

1. 箭头函数的this在函数定义的时候就确定了，是死的，而不是像普通函数一样，随着调用对象动态变化。
2. 箭头函数的this指向父级作用域的执行上下文（技巧：**因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数最近的function，与该function平级的执行上下文中的this即是箭头函数中的this**） 		
3. 箭头函数无法用call等方法修改this。

例1：首先，距离箭头函数最近的是getThis(){}，与该函数平级的执行上下文是obj中的执行上下文，箭头函数中的this就是下注释代码处的this，即obj。

```
        let obj = {
            //此处的this即是箭头函数中的this
            getThis: function () {
                return  ()=> {
                    console.log(this);
                }
            }
        }
        obj.getThis()(); //obj
```

例2：该段代码中存在两个箭头函数，this找不到对应的function(){}，所以一直往上找直到指向window。

```
        //代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。
       let obj = {
            getThis: ()=> {
                return  ()=> {
                    console.log(this);
                }
            }
        }
        obj.getThis()(); //window

```

## 3.29 手写bind

```
Function.prototype.bind = function(context, ...args) {
    var fn = this;
    return function(...rest) {
        return fn.apply(context,[...args, ...rest]);
    }
}
```

## 3.30 继承的方法

### **优点**

1. 提高了代码的复用性
2. 提高了代码的维护性
3. 让类与类直接产生了联系，是多态的前提

#### **弊端**

1. 类的耦合性增强了，但是开发的原则是低耦合，高内聚。目前来说继承的优点相比于这个缺点还是可以忽略的。

### new 做了什么

1. 创建空对象（实例对象）
2. 设置新对象的constructor指向构造函数，设置新对象的`__proto__`指向构造函数的prototype对象，扩展新对象的原型链。
3. 使用新对象调用构造函数，构造函数中的this被指向新对象；
4. 返回this指针，当存在显示的返回时，返回return后面的内容新建的空对象作废。

```
function test() {
 this.name = "test";
 }
 test.prototype = {
 a:{},
 b:{}
 }

var  c = new test();
```

### 原型链继承

**实现方式：将子类的原型链指向父类的对象实例**（父类的实例有父类的构造函数的属性和方法以及原型链的属性和方法）

```javascript
function Parent(){
  this.name = "parent";
  this.list = ['a'];
}
Parent.prototype.sayHi = function(){
  console.log('hi');
}
function Child(){

}
Child.prototype = new Parent();//Child.prototype.__proto__ === Parent.prototype //true
var child = new Child();//child.__proto__ === Child.prototype
console.log(child.name);
child.sayHi();

原理：任何实例的__proto__会指向构造函数的prototype，所以实例child的__proto__
指向构造函数Child的prototype。而Child.prototype又指向构造函数Parent的实例，所以
Parent的实例的__proto__指向Parent的prototype，也就是Child.prototype.__proto__指向Parent.prototype。
所以Child可以继承Parent的构造函数属性、方法和原型链属性、方法。
```

优点：可以继承父类构造函数的属性和方法，以及原型的属性和方法

缺点：无法向父类构造函数传参，并且所有实例共享父类实例的属性，如果父类实例的属性为引用类型，那么子类实例共享这个引用类型。

```
var a = new Child();
var b = new Child();
a.list.push('b');
console.log(b.list); // ['a','b']

```

### 构造函数继承

**实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数** 	

```
function Parent(name, id){
  this.id = id;
  this.name = name;
  this.printName = function(){
    console.log(this.name);
  }
}
Parent.prototype.sayName = function(){
  console.log(this.name);
};
function Child(name, id){
  Parent.call(this, name, id);
  // Parent.apply(this, arguments);
}
var child = new Child("jin", "1");
child.printName(); // jin
child.sayName() // Error
```

优点：可以解决原型链继承的缺点，即无法传参和共享引用类型的问题。

缺点：不可继承父类原型的构造方法，构造函数不可复用

### 组合继承

**结合原型链继承和构造函数继承**

```JavaScript
function Parent(name, id){
  this.id = id;
  this.name = name;
  this.list = ['a'];
  this.printName = function(){
    console.log(this.name);
  }
}
Parent.prototype.sayName = function(){
  console.log(this.name);
};
function Child(name, id){
  Parent.call(this, name, id);
  // Parent.apply(this, arguments);
}
Child.prototype = new Parent();//第一次调用父构造函数
var child = new Child("jin", "1");//第二次调用父构造函数
child.printName(); // jin
child.sayName() // jin

var a = new Child();
var b = new Child();
a.list.push('b');
console.log(b.list); // ['a']
```

优点：既可以继承原型链上的属性和方法，也可以调用构造函数传参

缺点：会执行两次父类的构造函数，消耗内存。

### 原型式继承

原理：类似Object.create，实际是把要子对象的`__proto__`指向父对象

```JavaScript
var parent = {
  names: ['a']
}
function copy(object) {
  function F() {}
  F.prototype = object;    
  return new F();//new 出了F的实例对象，实例对象的__proto__指向构造函数的prototype，所以child的__proto__指向parent.prototype
}
var child = copy(parent);
//child.__proto__ === parent true
```

缺点：这样造出来的子对象共享parent的引用类型；

### 寄生式继承

原理：二次封装原型式继承，在原型式继承的方法是进行了扩展；

```
function createObject(obj) {
  var o = copy(obj);
  o.getNames = function() {
    console.log(this.names);
    return this.names;
  }
  return o;
}
```

优点：可添加新的属性和方法 	

### 寄生组合式继承

原理：改进组合继承，组合继承在继承原型链的时候需要调用父类的构造函数。

我们的实际目的无非就是想要把子类的`__proto__`指向父类的prototype，那么利用原型式继承就可以达到，但是为了同时能够修改constructor的指向所以要用寄生式继承

```JavaScript
function inheritPrototype(subClass, superClass) {
  // 复制一份父类的原型
  var p = copy(superClass.prototype);
  // 修正构造函数
  p.constructor = subClass;
  // 设置子类原型
  subClass.prototype = p;
}

function Parent(name, id){
  this.id = id;
  this.name = name;
  this.list = ['a'];
  this.printName = function(){
    console.log(this.name);
  }
}
Parent.prototype.sayName = function(){
  console.log(this.name);
};
function Child(name, id){
  Parent.call(this, name, id);
  // Parent.apply(this, arguments);
}
inheritPrototype(Child, Parent);
```

优点：实现了组合继承的功能，同时借助寄生继承的思想避免了第二次调用构造函数。

### 在JavaScript中声明一个函数或者对象会发生什么

**创建一个对象**

1. 对象有proto属性，指向Object.prototype
2. 对象的prototype为undefined(此时的对象没有prototype，然后从原型链找，找到了Object的proto，指向undefined)

**创建一个函数**（函数本身就是一个特殊的对象）

1. 函数有proto属性，指向Function.prototype
2. 函数有prototype属性，属性指向一个对象，对象的constructor指向函数本身。

## 原生事件处理程序

### HTML事件处理程序

1. 通过设置HTML中的事件属性为执行的代码来注册事件处理程序
2. HTML事件属性中的代码可以访问全局作用域中的一切（通过with来实现的)
3. HTML事件属性中的代码可以直接访问该元素的属性
4. 在调用注册的程序之间得保证脚本加载完毕（可以用try catch来默认处理错误）
5. 代码高度耦合，使用不方便，不推荐

### DOM0级事件处理程序

1. 通过设置给每个元素的事件处理程序属性赋值函数来实现注册，赋值null来实现取消。
2. 由于这种赋值的注册方式使得同一个时间只能注册一个事件处理函数，即最后赋值的函数。
3. 只支持事件冒泡。
4. HTML中注册的时间处理程序，相当于DOM0级注册的。可以用指空来取消。

### DOM2级事件处理程序

1. 为事件添加一移除事件处理函数通过addEventListener和removeEventListener实现。
2. 这两个函数接受三个参数：时间名、处理函数、表示捕获还是冒泡的boolean，默认false表示冒泡。
3. 可以注册多个处理函数，触发顺序按照注册的顺序来。
4. 只能通过removeEventListener传入同样的参数来取消，所以匿名函数取消不了。

### DOM3级事件类型

#### 用户界面事件

- load：元素加载完成后触发，例window、img；
- unload：元素卸载后触发；
- abort：元素上相应的对象加载完成前被用户提前终止时触发；
- error：出错是触发，window加载失败，img下载失败；
- select：文本框（input、textarea）上当用户选择了一个或者多个字符时触发；
- resize:窗口缩放时触发；
- scroll：在有滚动条的元素上滚动时触发；

#### 焦点事件

- blur:元素失去焦点是触发，不冒泡；
- focus：元素获得焦点触发，不冒泡；
- focusin：focus的冒泡版；
- focusout：blur的冒泡版；

#### 鼠标事件

- click：用户点击或者键盘回车触发；
- dblclick：用户双击触发；
- mousedown：用户按下任意鼠标键时触发；
- mouseenter：鼠标移入时触发（不冒泡）；
- mouseleave：鼠标移除时触发（不冒泡）；
- mousemove：鼠标移动时反复触发；
- mouseover：鼠标移入时触发；
- mouseup：松开鼠标时触发；

#### clientX和clientY

![image-20220509194713364](images\image-20220509194713364.png)

#### pageX和pageY

想象把整个页面滚动栏隐藏的页面都展开，取鼠标的坐标。

#### screenX和screenY

![image-20220509195030931](images\image-20220509195030931.png)

#### 修饰键

![image-20220509195242341](images\image-20220509195242341.png)

#### 滚轮事件

mousewheel

wheelDelta的值（-+120）

![image-20220509200024186](images\image-20220509200024186.png)

#### 输入与键盘事件

- keydown：按下就触发，按住不动持续触发；

- keyup：用户释放按键是触发；
- textInput：输入内容触发；

event.keyCode表示键码

![image-20220509200559492](images\image-20220509200559492.png)

#### HTML5事件

- beforunload：离开页面前触发
- DOMContentLoaded：window的load事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而DOMContentLoaded事件会在DOM树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS文件或其他资源加载完成。相对于load事件，DOMContentLoaded可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。
- hashchange:HTML5增加了hashchange事件，用于在URL散列值（URL最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在Ajax应用程序中使用URL散列值存储状态信息或路由导航信息。onhashchange事件处理程序必须添加给window，每次URL散列值发生变化时会调用它。event对象有两个新属性：oldURL和newURL。这两个属性分别保存变化前后的URL，而且是包含散列值的完整URL。下面的例子展示了如何获取变化前后的URL：

## 图片懒加载和图片预加载

### 图片预加载

```javascript
window.addEventListener('load',()=>{
    let image = new Image();
    image.addEventListener('load',()=>{
        consolo.log('image loaded');
    })
    image.src = 'smile.gif'//只要设置了src就会下载，不需要添加到html
})
```











































# Node.js

## 4.1 概念

Node.js是一个JavaScript运行时环境

1. Node.js在浏览器之外运行Google的JavaScript引擎V8，利用事件循环、非阻塞异步IO等技术提高性能
2. Node.js提供了浏览器环境没有的IO，所以使得JavaScript可以在后端运行。

### 非阻塞异步IO

我们都知道Node.js采用了非阻塞式异步IO，使得在进行IO操作的时候，线程无需等待阻塞等待IO操作的完成，可以执行其他任务。

对于一般的多线程的语言来说，IO操作都是同步的，会阻塞后面的任务，所以要按顺序同步的执行一个个IO操作，造成CPU资源等待浪费。

而异步IO不会阻塞后面任务的执行，通过事件来通知IO操作哦的完成。所以Node.js中，IO操作相当于是在后台执行的，在cpu进行计算任务的时候完成。

所以Node.js在单线程结合异步IO的情况下也能实现多线程实现的高并发量。

![image-20220329213328656](images\image-20220329213328656.png)

### 事件驱动

因为JavaScript是单线程的，所以为了提高CPU的利用率，所以JavaScript是异步的。那么如果编排异步执行的任务来实现同步的效果，所以就有了事件驱动。比如服务器Nginx也摈弃了多线程的方式，采用与node相同的时间驱动。

事件驱动就是当有新请求到来时，Node.js会把请求加入到事件队列中，通过循环来检测队列中事件的状态变化。一旦有事件的状态发生变化，就执行该事件的回调函数。

比如读取文件，当文件读取完毕就会触发对于的状态，执行回调函数。

### 异步单线程的优缺点

优点：

1. 异步的特性使得Node.js处理高并发的场景性能优越

2. 单线程的特点使得，Node.js适合I/O密集型应用，I/O密集型应用CPU占有率较低，大部分的时间再做I/O操作。

缺点：

1. Node的缺点同样也是来自异步和单线程，首先是单线程不适合CPU密集型应用，虽然Node能够开启新的线程，但是线程之间的协作也不如多线程效率高。
2. 单线程不能充分利用CPU，只支持单核CPU。
3. 异步编程相对于同步编程，实现起来比较困难，需要熟悉业务逻辑，合理编排任务。

### 应用场景

I/O密集型应用，如果计算太多会阻塞进程。

- 管理系统
- 实时交互系统

## 4.2 全局对象

不同于浏览器，node中的全局对象为global

全局对象在去全局作用域中，任何全局变量、函数、对象都是global的属性值；

#### 全局对象可以分为两类

- global的属性，全局可用的对象
- 模块级别的全局对象，模块内都可用

#### global的属性

- Class：Buffer
- process
- console
- clearInterval、setInterval
- clearTimeout、setTimeout
- global

##### Class:Buffer

用于处理二进制以及非Unicode编码的数据。

Buffer类似一个整数数组，在V8堆的原始空间为它分配了内存，一旦创建了Buffer实例，则长度固定不变了。

##### Process

进程对象，提供当前进程的信息和控制。



例如在执行`node`程序的过程中，如果需要传递参数，我们想要获取这个参数需要在`process`内置对象中

启动进程：

```
 node index.js 参数1 参数2 参数3
```

index.js文件如下：

```
process.argv.forEach((val, index) => {
  console.log(`${index}: ${val}`);
});
```

输出如下：

```
/usr/local/bin/node
/Users/mjr/work/node/process-args.js
参数1
参数2
参数3
```

##### console

用来打印`stdout`和`stderr`

最常用的输入内容的方式：console.log

```
console.log("hello");
```

清空控制台：console.clear

```
console.clear
```

打印函数的调用栈：console.trace

```
function test() {
    demo();
}

function demo() {
    foo();
}

function foo() {
    console.trace();
}

test();
```

[![img](https://camo.githubusercontent.com/2014a8d0f6bab5b4069c92f657b9e3f5bbcc50a6e73369343c2536363fcfc380/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39316236646262302d633261332d313165622d383566362d3666616337376330633962332e706e67)](https://camo.githubusercontent.com/2014a8d0f6bab5b4069c92f657b9e3f5bbcc50a6e73369343c2536363fcfc380/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39316236646262302d633261332d313165622d383566362d3666616337376330633962332e706e67)

##### clearInterval、setInterval

设置定时器与清除定时器

```
setInterval(callback, delay[, ...args])
```

`callback`每`delay`毫秒重复执行一次

`clearInterval`则为对应发取消定时器的方法

##### clearTimeout、setTimeout

设置延时器与清除延时器

```
setTimeout(callback,delay[,...args])
```

`callback`在`delay`毫秒后执行一次

`clearTimeout`则为对应取消延时器的方法

##### global

全局命名空间对象，墙面讲到的`process`、`console`、`setTimeout`等都有放到`global`中

```
console.log(process === global.process) // true
```

#### 模块级别的全局对象

这些全局对象是模块中的变量，只是每个模块都有，看起来就像全局变量，像在命令交互中是不可以使用，包括：

- __dirname
- __filename
- exports
- module
- require

##### __dirname

获取当前文件所在的路径，不包括后面的文件名

从 `/Users/mjr` 运行 `node example.js`：

```
console.log(__dirname);// 打印: /Users/mjr
```

##### __filename

获取当前文件所在的路径和文件名称，包括后面的文件名称

从 `/Users/mjr` 运行 `node example.js`：

```
console.log(__filename);// 打印: /Users/mjr/example.js
```

##### exports

`module.exports` 用于指定一个模块所导出的内容，即可以通过 `require()` 访问的内容

```
exports.name = name;exports.age = age;exports.sayHello = sayHello;
```

##### module

对当前模块的引用，通过`module.exports` 用于指定一个模块所导出的内容，即可以通过 `require()` 访问的内容

##### require

用于引入模块、 `JSON`、或本地文件。 可以从 `node_modules` 引入模块。

可以使用相对路径引入本地模块或`JSON`文件，路径会根据`__dirname`定义的目录名或当前工作目录进行处理

## 4.3 process

`process` 对象是一个全局变量，提供了有关当前 `Node.js `进程的信息并对其进行控制，作为一个全局变量

我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器

当我们启动一个`js`文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享

由于`JavaScript`是一个单线程语言，所以通过`node xxx`启动一个文件后，只有一条主线程

#### 属性与方法

关于`process`常见的属性有如下：

- process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息
- process.nextTick：这个在谈及 `EventLoop` 时经常为会提到
- process.pid：获取当前进程id
- process.ppid：当前进程对应的父进程
- process.cwd()：获取当前进程工作目录，
- process.platform：获取当前进程运行的操作系统平台
- process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值
- 进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听
- 三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出
- process.title 指定进程名称，有的时候需要给进程指定一个名称

下面再稍微介绍下某些方法的使用：

#### process.cwd()

返回当前 `Node `进程执行的目录

一个` Node` 模块 `A` 通过 NPM 发布，项目 `B` 中使用了模块 `A`。在 `A` 中需要操作 `B` 项目下的文件时，就可以用 `process.cwd()` 来获取 `B` 项目的路径

#### process.argv

在终端通过 Node 执行命令的时候，通过 `process.argv` 可以获取传入的命令行参数，返回值是一个数组：

- 0: Node 路径（一般用不到，直接忽略）
- 1: 被执行的 JS 文件路径（一般用不到，直接忽略）
- 2~n: 真实传入命令的参数

所以，我们只要从 `process.argv[2]` 开始获取就好了

```
const args = process.argv.slice(2);
```

#### process.env

返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。

一般我们会在 `process.env` 上挂载一些变量标识当前的环境。比如最常见的用 `process.env.NODE_ENV` 区分 `development` 和 `production`

在 `vue-cli` 的源码中也经常会看到 `process.env.VUE_CLI_DEBUG` 标识当前是不是 `DEBUG` 模式

#### process.nextTick()

我们知道`NodeJs`是基于事件轮询，在这个过程中，同一时间只会处理一件事情

在这种处理模式下，`process.nextTick()`就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行

例如下面例子将一个`foo`函数在下一个时间点调用

```
function foo() {
    console.error('foo');
}

process.nextTick(foo);
console.error('bar');
```

输出结果为`bar`、`foo`

虽然下述方式也能实现同样效果：

```
setTimeout(foo, 0);
console.log('bar');
```

两者区别在于：

- process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback
- setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的

## 4.4 fs模块

fs（filesystem），该模块提供本地文件的读写能力，基本上是`POSIX`文件操作命令的简单包装

可以说，所有与文件的操作都是通过`fs`核心模块实现

导入模块如下：

```
const fs = require('fs');
```

这个模块对所有文件系统操作提供异步（不具有`sync` 后缀）和同步（具有 `sync` 后缀）两种操作方式，而供开发者选择

#### 方法

下面针对`fs`模块常用的方法进行展开：

- 文件读取
- 文件写入
- 文件追加写入
- 文件拷贝
- 创建目录

#### 文件读取

##### fs.readFileSync

同步读取，参数如下：

- 第一个参数为读取文件的路径或文件描述符
- 第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding

结果为返回文件的内容

```
const fs = require("fs");

let buf = fs.readFileSync("1.txt");
let data = fs.readFileSync("1.txt", "utf8");

console.log(buf); // <Buffer 48 65 6c 6c 6f>
console.log(data); // Hello
```

##### fs.readFile

异步读取方法 `readFile` 与 `readFileSync` 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 `err`（错误）和 `data`（数据），该方法没有返回值，回调函数在读取文件成功后执行

```
const fs = require("fs");

fs.readFile("1.txt", "utf8", (err, data) => {
   if(!err){
       console.log(data); // Hello
   }
});
```

#### 文件写入

##### writeFileSync

同步写入，有三个参数：

- 第一个参数为写入文件的路径或文件描述符
- 第二个参数为写入的数据，类型为 String 或 Buffer
- 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding

```
const fs = require("fs");

fs.writeFileSync("2.txt", "Hello world");
let data = fs.readFileSync("2.txt", "utf8");

console.log(data); // Hello world
```

##### writeFile

异步写入，`writeFile` 与 `writeFileSync` 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 `err`（错误），回调函数在文件写入数据成功后执行

```
const fs = require("fs");

fs.writeFile("2.txt", "Hello world", err => {
    if (!err) {
        fs.readFile("2.txt", "utf8", (err, data) => {
            console.log(data); // Hello world
        });
    }
});
```

#### 文件追加写入

##### appendFileSync

参数如下：

- 第一个参数为写入文件的路径或文件描述符
- 第二个参数为写入的数据，类型为 String 或 Buffer
- 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding

```
const fs = require("fs");

fs.appendFileSync("3.txt", " world");
let data = fs.readFileSync("3.txt", "utf8");
```

##### appendFile

异步追加写入方法 `appendFile` 与 `appendFileSync` 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 `err`（错误），回调函数在文件追加写入数据成功后执行

```
const fs = require("fs");

fs.appendFile("3.txt", " world", err => {
    if (!err) {
        fs.readFile("3.txt", "utf8", (err, data) => {
            console.log(data); // Hello world
        });
    }
});
```

#### 文件拷贝

##### copyFileSync

同步拷贝

```
const fs = require("fs");

fs.copyFileSync("3.txt", "4.txt");
let data = fs.readFileSync("4.txt", "utf8");

console.log(data); // Hello world
```

##### copyFile

异步拷贝

```
const fs = require("fs");

fs.copyFile("3.txt", "4.txt", () => {
    fs.readFile("4.txt", "utf8", (err, data) => {
        console.log(data); // Hello world
    });
});
```

#### 创建目录

##### mkdirSync

同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常

```
// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdirSync("a/b/c")
```

##### mkdir

异步创建，第二个参数为回调函数

```
fs.mkdir("a/b/c", err => {
    if (!err) console.log("创建成功");
});
```

## 4.5 **Buffer**

#### 一、是什么

在`Node`应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而`Buffer`就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据

在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量

如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理

这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 `RAM` 中

简单来讲，`Nodejs`不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在`Buffer`中，即在`RAM`中，直至将它们发送完毕

上面讲到了`Buffer`是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：`00000000`，也就是一个字节

例如：

```
const buffer = Buffer.from("why")
```

其存储过程如下图所示：

[![img](https://camo.githubusercontent.com/92a6fa5e76070f97acf90e5b25d84eecf486850e176010df7bcbec10274c21d3/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32303337313235302d633639632d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/92a6fa5e76070f97acf90e5b25d84eecf486850e176010df7bcbec10274c21d3/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32303337313235302d633639632d313165622d616239302d6439616538313462323430642e706e67)

#### 二、使用方法

`Buffer` 类在全局作用域中，无须`require`导入

创建`Buffer`的方法有很多种，我们讲讲下面的两种常见的形式：

- Buffer.from()
- Buffer.alloc()

##### Buffer.from()

```
const b1 = Buffer.from('10');
const b2 = Buffer.from('10', 'utf8');
const b3 = Buffer.from([10]);
const b4 = Buffer.from(b3);

console.log(b1, b2, b3, b4); // <Buffer 31 30> <Buffer 31 30> <Buffer 0a> <Buffer 0a>
```

##### Buffer.alloc()

```
const bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区
const bAlloc2 = Buffer.alloc(10, 1); // 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节
console.log(bAlloc1); // <Buffer 00 00 00 00 00 00 00 00 00 00>
console.log(bAlloc2); // <Buffer 01 01 01 01 01 01 01 01 01 01>
```

在上面创建`buffer`后，则能够`toString`的形式进行交互，默认情况下采取`utf8`字符编码形式，如下

```
const buffer = Buffer.from("你好");
console.log(buffer);
// <Buffer e4 bd a0 e5 a5 bd>
const str = buffer.toString();
console.log(str);
// 你好
```

如果编码与解码不是相同的格式则会出现乱码的情况，如下：

```
const buffer = Buffer.from("你好","utf-8 ");
console.log(buffer);
// <Buffer e4 bd a0 e5 a5 bd>
const str = buffer.toString("ascii");
console.log(str); 
// d= e%=
```

当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：

```
const buf = Buffer.from('Node.js 技术栈', 'UTF-8');

console.log(buf)          // <Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88>
console.log(buf.length)   // 17

console.log(buf.toString('UTF-8', 0, 9))  // Node.js �
console.log(buf.toString('UTF-8', 0, 11)) // Node.js 技
```

所支持的字符集有如下：

- ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的
- utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8
- utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF）
- ucs2，utf16le 的别名
- base64：Base64 编码
- latin：一种把 Buffer 编码成一字节编码的字符串的方式
- binary：latin1 的别名，
- hex：将每个字节编码为两个十六进制字符

#### 三、应用场景

`Buffer`的应用场景常常与流的概念联系在一起，例如有如下：

- I/O操作
- 加密解密
- zlib.js

##### I/O操作

通过流的形式，将一个文件的内容读取到另外一个文件

```
const fs = require('fs');

const inputStream = fs.createReadStream('input.txt'); // 创建可读流
const outputStream = fs.createWriteStream('output.txt'); // 创建可写流

inputStream.pipe(outputStream); // 管道读写
```

##### 加解密

在一些加解密算法中会遇到使用 `Buffer`，例如 `crypto.createCipheriv` 的第二个参数 `key` 为 `string` 或 `Buffer` 类型

##### zlib.js

`zlib.js` 为 `Node.js` 的核心库之一，其利用了缓冲区（`Buffer`）的功能来操作二进制数据流，提供了压缩或解压功能

## 4.6 Stream

#### 一、是什么

流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出

`Node.js`中很多对象都实现了流，总之它是会冒数据（以 `Buffer` 为单位）

它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中

流可以分成三部分：`source`、`dest`、`pipe`

在`source`和`dest`之间有一个连接的管道`pipe`,它的基本语法是`source.pipe(dest)`，`source`和`dest`就是通过pipe连接，让数据从`source`流向了`dest`，如下图所示：

[![img](https://camo.githubusercontent.com/43083d2d09dd6acaf02b554eb0c1858093bc3c71537eec10326f5babfce6a9ae/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61656330353637302d633736662d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/43083d2d09dd6acaf02b554eb0c1858093bc3c71537eec10326f5babfce6a9ae/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61656330353637302d633736662d313165622d616239302d6439616538313462323430642e706e67)

#### 二、种类

在`NodeJS`，几乎所有的地方都使用到了流的概念，分成四个种类：

- 可写流：可写入数据的流。例如 fs.createWriteStream()  可以使用流将数据写入文件
- 可读流： 可读取数据的流。例如fs.createReadStream() 可以从文件读取内容
- 双工流： 既可读又可写的流。例如 net.Socket
- 转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据

在`NodeJS`中`HTTP`服务器模块中，`request` 是可读流，`response` 是可写流。还有`fs` 模块，能同时处理可读和可写文件流

可读流和可写流都是单向的，比较容易理解，而另外两个是双向的

##### 双工流

之前了解过`websocket`通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系

如下图所示：

[![img](https://camo.githubusercontent.com/7d8265071b52076d1f2b96a2feff655d0914d940aa9f2898c59ff674baa2a7a0/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62376163366430302d633736662d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/7d8265071b52076d1f2b96a2feff655d0914d940aa9f2898c59ff674baa2a7a0/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62376163366430302d633736662d313165622d616239302d6439616538313462323430642e706e67)

基本代码如下：

```
const { Duplex } = require('stream');

const myDuplex = new Duplex({
  read(size) {
    // ...
  },
  write(chunk, encoding, callback) {
    // ...
  }
});
```

##### 双工流

双工流的演示图如下所示：

[![img](https://camo.githubusercontent.com/07be48aed93596a48418da19e1ec710e7cd5d46dc0dfd0da3d5c614ba1e8ac89/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63303238383362302d633736662d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/07be48aed93596a48418da19e1ec710e7cd5d46dc0dfd0da3d5c614ba1e8ac89/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63303238383362302d633736662d313165622d616239302d6439616538313462323430642e706e67)

除了上述压缩包的例子，还比如一个 `babel`，把`es6`转换为，我们在左边写入 `es6`，从右边读取 `es5`

基本代码如下所示：

```
const { Transform } = require('stream');

const myTransform = new Transform({
  transform(chunk, encoding, callback) {
    // ...
  }
});
```

#### 三、应用场景

`stream`的应用场景主要就是处理`IO`操作，而`http`请求和文件操作都属于`IO`操作

思想一下，如果一次`IO`操作过大，硬件的开销就过大，而将此次大的`IO`操作进行分段操作，让数据像水管一样流动，知道流动完成

常见的场景有：

- get请求返回文件给客户端
- 文件操作
- 一些打包工具的底层操作

##### get请求返回文件给客户端

使用`stream`流返回文件，`res`也是一个`stream`对象，通过`pipe`管道将文件数据返回

```
const server = http.createServer(function (req, res) {
    const method = req.method; // 获取请求方法
    if (method === 'GET') { // get 请求
        const fileName = path.resolve(__dirname, 'data.txt');
        let stream = fs.createReadStream(fileName);
        stream.pipe(res); // 将 res 作为 stream 的 dest
    }
});
server.listen(8000);
```

##### 文件操作

创建一个可读数据流`readStream`，一个可写数据流`writeStream`，通过`pipe`管道把数据流转过去

```
const fs = require('fs')
const path = require('path')

// 两个文件名
const fileName1 = path.resolve(__dirname, 'data.txt')
const fileName2 = path.resolve(__dirname, 'data-bak.txt')
// 读取文件的 stream 对象
const readStream = fs.createReadStream(fileName1)
// 写入文件的 stream 对象
const writeStream = fs.createWriteStream(fileName2)
// 通过 pipe执行拷贝，数据流转
readStream.pipe(writeStream)
// 数据读取完成监听，即拷贝完成
readStream.on('end', function () {
    console.log('拷贝完成')
})
```

##### 一些打包工具的底层操作

目前一些比较火的前端打包构建工具，都是通过`node.js`编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来`stream`，如`gulp`

## 4.7 EventEmitter

#### 一、是什么

我们了解到，`Node `采用了事件驱动机制，而`EventEmitter `就是`Node`实现事件驱动的基础

在`EventEmitter`的基础上，`Node `几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作

`Node.js` 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件

这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上

#### 二、使用方法

`Node `的`events`模块只提供了一个`EventEmitter`类，这个类实现了`Node`异步事件驱动架构的基本模式——观察者模式

在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们

基本代码如下所示：

```
const EventEmitter = require('events')

class MyEmitter extends EventEmitter {}
const myEmitter = new MyEmitter()

function callback() {
    console.log('触发了event事件！')
}
myEmitter.on('event', callback)
myEmitter.emit('event')
myEmitter.removeListener('event', callback);
```

通过实例对象的`on`方法注册一个名为`event`的事件，通过`emit`方法触发该事件，而`removeListener`用于取消事件的监听

关于其常见的方法如下：

- emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部
- emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部
- emitter.emit(eventName[, ...args])：触发类型为 eventName 的监听事件
- emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件
- emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除
- emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件

#### 三、实现过程

通过上面的方法了解，`EventEmitter`是一个构造函数，内部存在一个包含所有事件的对象

```
class EventEmitter {
    constructor() {
        this.events = {};
    }
}
```

其中`events`存放的监听事件的函数的结构如下：

```
{
  "event1": [f1,f2,f3]，
  "event2": [f4,f5]，
  ...
}
```

然后开始一步步实现实例方法，首先是`emit`，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：

```
emit(type, ...args) {
    this.events[type].forEach((item) => {
        Reflect.apply(item, this, args);
    });
}
```

当实现了`emit`方法之后，然后实现`on`、`addListener`、`prependListener`这三个实例方法，都是添加事件监听触发函数，实现也是大同小异

```
on(type, handler) {
    if (!this.events[type]) {
        this.events[type] = [];
    }
    this.events[type].push(handler);
}

addListener(type,handler){
    this.on(type,handler)
}

prependListener(type, handler) {
    if (!this.events[type]) {
        this.events[type] = [];
    }
    this.events[type].unshift(handler);
}
```

紧接着就是实现事件监听的方法`removeListener/on`

```
removeListener(type, handler) {
    if (!this.events[type]) {
        return;
    }
    this.events[type] = this.events[type].filter(item => item !== handler);
}

off(type,handler){
    this.removeListener(type,handler)
}
```

最后再来实现`once`方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过`fired`属性值判断事件函数是否执行过

```
once(type, handler) {
    this.on(type, this._onceWrap(type, handler, this));
  }

  _onceWrap(type, handler, target) {
    const state = { fired: false, handler, type , target};
    const wrapFn = this._onceWrapper.bind(state);
    state.wrapFn = wrapFn;
    return wrapFn;
  }

  _onceWrapper(...args) {
    if (!this.fired) {
      this.fired = true;
      Reflect.apply(this.handler, this.target, args);
      this.target.off(this.type, this.wrapFn);
    }
 }
```

完整代码如下：

```
class EventEmitter {
    constructor() {
        this.events = {};
    }

    on(type, handler) {
        if (!this.events[type]) {
            this.events[type] = [];
        }
        this.events[type].push(handler);
    }

    addListener(type,handler){
        this.on(type,handler)
    }

    prependListener(type, handler) {
        if (!this.events[type]) {
            this.events[type] = [];
        }
        this.events[type].unshift(handler);
    }

    removeListener(type, handler) {
        if (!this.events[type]) {
            return;
        }
        this.events[type] = this.events[type].filter(item => item !== handler);
    }

    off(type,handler){
        this.removeListener(type,handler)
    }

    emit(type, ...args) {
        this.events[type].forEach((item) => {
            Reflect.apply(item, this, args);
        });
    }

    once(type, handler) {
        this.on(type, this._onceWrap(type, handler, this));
    }

    _onceWrap(type, handler, target) {
        const state = { fired: false, handler, type , target};
        const wrapFn = this._onceWrapper.bind(state);
        state.wrapFn = wrapFn;
        return wrapFn;
    }

    _onceWrapper(...args) {
        if (!this.fired) {
            this.fired = true;
            Reflect.apply(this.handler, this.target, args);
            this.target.off(this.type, this.wrapFn);
        }
    }
}
```

测试代码如下：

```javascript
const ee = new EventEmitter();// 注册所有事件ee.once('wakeUp', (name) => { console.log(`${name} 1`); });ee.on('eat', (name) => { console.log(`${name} 2`) });ee.on('eat', (name) => { console.log(`${name} 3`) });const meetingFn = (name) => { console.log(`${name} 4`) };ee.on('work', meetingFn);ee.on('work', (name) => { console.log(`${name} 5`) });ee.emit('wakeUp', 'xx');ee.emit('wakeUp', 'xx');         // 第二次没有触发ee.emit('eat', 'xx');ee.emit('work', 'xx');ee.off('work', meetingFn);        // 移除事件ee.emit('work', 'xx');           // 再次工作
```

## 4.8 事件循环

### 一、是什么

在[浏览器事件循环](https://github.com/febobo/web-interview/issues/73)中，我们了解到`javascript`在浏览器中的事件循环机制，其是根据`HTML5`定义的规范来实现

而在`NodeJS`中，事件循环是基于`libuv`实现，`libuv`是一个多平台的专注于异步IO的库，如下图最右侧所示：

[![img](https://camo.githubusercontent.com/656844a073b6159454bd9711f58a5bd3348cd97d175b804e6d8021bf553f5c42/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613639306239302d633930652d313165622d383566362d3666616337376330633962332e706e67)](https://camo.githubusercontent.com/656844a073b6159454bd9711f58a5bd3348cd97d175b804e6d8021bf553f5c42/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613639306239302d633930652d313165622d383566362d3666616337376330633962332e706e67)

上图`EVENT_QUEUE` 给人看起来只有一个队列，但`EventLoop`存在6个阶段，每个阶段都有对应的一个先进先出的回调队列

### 二、流程

上节讲到事件循环分成了六个阶段，对应如下：

[![img](https://camo.githubusercontent.com/6fa1faa07ea642def7afdee2fcee7a2d91efc7d3e798b062203ee8c168906310/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326533346438302d633930652d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/6fa1faa07ea642def7afdee2fcee7a2d91efc7d3e798b062203ee8c168906310/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326533346438302d633930652d313165622d616239302d6439616538313462323430642e706e67)

- timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调
- 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数
- I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调
- 闲置阶段(idle, prepare)：仅系统内部使用
- 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞
- 检查阶段(check)：setImmediate() 回调函数在这里执行
- 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)

每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段

除了上述6个阶段，还存在`process.nextTick`，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队

流程图如下所示：

[![img](https://camo.githubusercontent.com/3c7dcc917b9961ff7541bdc590067e3448e9809248ef98696fb50619bfdfcb38/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66626537333164302d633930652d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/3c7dcc917b9961ff7541bdc590067e3448e9809248ef98696fb50619bfdfcb38/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66626537333164302d633930652d313165622d616239302d6439616538313462323430642e706e67)

在`Node`中，同样存在宏任务和微任务，与浏览器中的事件循环相似

微任务对应有：

在javascript中，微任务包含：1、“Promise”；2、“Object.observe”；3、“MutationObserver”；4、Node.js环境下的“process.nextTick”；5、“async/await”。

宏任务对应有：

- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。



- timer queue：setTimeout、setInterval
- poll queue：IO事件
- check queue：setImmediate
- close queue：close事件

其执行顺序为：

- next tick microtask queue
- other microtask queue
- timer queue
- poll queue
- check queue
- close queue

**面试中该如何回答呢？ 下面是我个人推荐的回答：**

**简要**

执行同步代码，这属于宏任务

执行栈为空，查询是否有微任务需要执行

执行所有微任务

必要的话渲染 UI

然后开始下一轮 `Event loop`，执行宏任务中的异步代码

![image-20220513201933110](images\image-20220513201933110.png)

**详细**

- 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行
- 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务
- 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行
- 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行
- 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

```js
setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function(resolve, reject) {
  console.log(2);
  resolve()
}).then(function() {
  console.log(3)
});
process.nextTick(function () {
  console.log(4)
})
console.log(5)
```

- 第一轮：主线程开始执行，遇到`setTimeout`，将setTimeout的回调函数丢到宏任务队列中，在往下执行`new Promise`立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到`process.nextTick`，同样将回调函数扔到微任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和`nextTick`两个微任务，先执行哪个呢？`process.nextTick`指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。
- 第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431

### 三、题目

通过上面的学习，下面开始看看题目

```
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}

async function async2() {
    console.log('async2')
}

console.log('script start')

setTimeout(function () {
    console.log('setTimeout0')
}, 0)

setTimeout(function () {
    console.log('setTimeout2')
}, 300)

setImmediate(() => console.log('setImmediate'));

process.nextTick(() => console.log('nextTick1'));

async1();

process.nextTick(() => console.log('nextTick2'));

new Promise(function (resolve) {
    console.log('promise1')
    resolve();
    console.log('promise2')
}).then(function () {
    console.log('promise3')
})

console.log('script end')
```

分析过程：

- 先找到同步任务，输出script start
- 遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中
- 遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中
- 遇到第一个setImmediate，将里面的回调函数放到 check 队列中
- 遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行
- 执行 async1函数，输出 async1 start
- 执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环
- 遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行
- 遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2
- then里面的回调函数进入微任务队列
- 遇到同步任务，输出 script end
- 执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2
- 然后执行微任务队列，依次输出 async1 end、promise3
- 执行timer 队列，依次输出 setTimeout0
- 接着执行 check  队列，依次输出 setImmediate
- 300ms后，timer 队列存在任务，执行输出 setTimeout2

执行结果如下：

```
script start
async1 start
async2
promise1
promise2
script end
nextTick1
nextTick2
async1 end
promise3
setTimeout0
setImmediate
setTimeout2
```

最后有一道是关于`setTimeout`与`setImmediate`的输出顺序

```
setTimeout(() => {
  console.log("setTimeout");
}, 0);

setImmediate(() => {
  console.log("setImmediate");
});
```

输出情况如下：

```
情况一：
setTimeout
setImmediate

情况二：
setImmediate
setTimeout
```

分析下流程：

- 外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段
- 遇到`setTimeout`，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入`times`阶段
- 遇到`setImmediate`塞入`check`阶段
- 同步代码执行完毕，进入Event Loop
- 先进入`times`阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足`setTimeout`条件，执行回调，如果没过1毫秒，跳过
- 跳过空的阶段，进入check阶段，执行`setImmediate`回调

这里的关键在于这1ms，如果同步代码执行时间较长，进入`Event Loop`的时候1毫秒已经过了，`setTimeout`先执行，如果1毫秒还没到，就先执行了`setImmediate`

### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_7-3-requestanimationframe用法) 7.3 requestAnimationFrame用法

> 在Web应用中，实现动画效果的方法比较多，`Javascript` 中可以通过定时器 `setTimeout` 来实现，`css3` 可以使用 `transition` 和 `animation` 来实现，`html5` 中的 `canvas` 也可以实现。除此之外，html5 还提供一个专门用于请求动画的`API`，那就是 `requestAnimationFrame`，顾名思义就是请求动画帧

#### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_1-页面可见) 1.页面可见

> 当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个 `visibilitychange`事件,并设置`document.hidden`属性为true；切换到显示状态时，页面为可见，也同样触发一个 `visibilitychange` 事件，设置`document.hidden`属性为`false`

#### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_2-动画帧请求回调函数列表) 2.动画帧请求回调函数列表

> 每个`Document`都有一个动画帧请求回调函数列表，该列表可以看成是由`<handlerId, callback>`元组组成的集合。其中`handlerId`是一个整数，唯一地标识了元组在列表中的位置；`callback`是回调函数

#### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_3-屏幕刷新频率) 3.屏幕刷新频率

> 即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是`60Hz`， 这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响

#### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_4-动画原理) 4.动画原理

> 根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢

刷新频率为`60Hz`的屏幕每`16.7ms`刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即`1px`。这样一来，屏幕每次刷出来的图像位置都比前一个要差`1px`，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画

#### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_5-requestanimationframe用法) 5.requestAnimationFrame用法

异步，传入的函数在重绘之前调用

**1. 写法：handlerId = requestAnimationFrame(callback)**

- 传入一个`callback`函数，即动画函数
- 返回值`handlerId`为浏览器定义的、大于`0`的整数，唯一标识了该回调函数在列表中位置

**2. 浏览器执行过程**

- 首先要判断`document.hidden`属性是否为`true`,即页面处于可见状态下才会执行
- 浏览器清空上一轮的动画函数
- 这个方法返回的handlerId 值会和动画函数callback，以`<handlerId , callback>` 进入到动画帧请求回调函数列
- 浏览器会遍历动画帧请求回调函数列表，根据handlerId 的值大小，依次去执行相应的动画函数

**3. 取消动画函数的方法**

```text
cancelAnimationFrame(handlerId)
```

#### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_6-与settimeout对比) 6.与setTimeout对比

> 理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因

- `setTimeout`的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 `setTimeout` 的实际执行时间一般要比其设定的时间晚一些
- 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。

> 以上两种情况都会导致`setTimeout`的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢

> 首先要明白，`setTimeout`的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔`16.7ms`刷新一次，而`setTimeout`每隔`10ms`设置图像向左移动`1px`， 就会出现如下绘制过程：

- 第0ms:  屏幕未刷新，等待中，setTimeout也未执行，等待中；
- 第10ms:  屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px；
- 第16.7ms:  屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中；
- 第20ms:  屏幕未刷新，等待中，setTimeout开始执行并设置left=2px;
- 第30ms:  屏幕未刷新，等待中，setTimeout开始执行并设置left=3px;
- 第33.4ms: 屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中； …

> 从上面的绘制过程中可以看出，屏幕没有更新`left=2px`的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿

> 与`setTimeout`相比，`requestAnimationFrame`最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是`60Hz`,那么回调函数就每16.7ms被执行一次，如果刷新率是`75Hz`，那么这个时间间隔就变成了`1000/75=13.3ms`，换句话说就是，`requestAnimationFrame`的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

```js
var progress = 0;
//回调函数
function render() {  
  progress += 1; //修改图像的位置  
  if (progress < 100) {  //在动画没有结束前，递归渲染    
    window.requestAnimationFrame(render); 
  }
}
//第一帧渲染
window.requestAnimationFrame(render)
```

**除此之外，requestAnimationFrame还有以下两个优势**

- CPU节能：使用`setTimeout`实现的动画，当页面被隐藏或最小化时，`setTimeout` 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而`requestAnimationFrame`则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的`requestAnimationFrame`也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了`CPU`开销
- 函数节流：在高频率事件(`resize`,`scroll`等)中，为了防止在一个刷新间隔内发生多次函数执行，使用`requestAnimationFrame`可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每`16.7ms`刷新一次，多次绘制并不会在屏幕上体现出来

#### [#](https://interview2.poetries.top/excellent-docs/5-浏览器模块.html#_7-优雅降级) 7.优雅降级

> 由于`requestAnimationFrame`目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀。因此需要通过优雅降级的方式对`requestAnimationFrame`进行封装，优先使用高级特性，然后再根据不同浏览器的情况进行回退，直至只能使用`setTimeout`的情况。下面的代码就是有人在github上提供的polyfill，详细介绍请参考github代码 [requestAnimationFrame](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdarius%2FrequestAnimationFrame)

[ ](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdarius%2FrequestAnimationFrame)

> [ (opens new window)](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdarius%2FrequestAnimationFrame)

```js
if (!Date.now)
    Date.now = function() { return new Date().getTime(); };
 
(function() {
    'use strict';
     
    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
        var vp = vendors[i];
        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];
        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']
                                   || window[vp+'CancelRequestAnimationFrame']);
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy
        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
        var lastTime = 0;
        window.requestAnimationFrame = function(callback) {
            var now = Date.now();
            var nextTime = Math.max(lastTime + 16, now);
            return setTimeout(function() { callback(lastTime = nextTime); },
                              nextTime - now);
        };
        window.cancelAnimationFrame = clearTimeout;
    }
}())
```

### requestidelcallback

https://interview2.poetries.top/docs/simply.html#_14-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8Erequestanimationframe%E3%80%81requestidlecallback

## 4.9 Node模块加载

### 一、模块规范

`NodeJS`对`CommonJS`进行了支持和实现，让我们在开发`node`的过程中可以方便的进行模块化开发：

- 在Node中每一个js文件都是一个单独的模块
- 模块中包括CommonJS规范的核心变量：exports、module.exports、require
- 通过上述变量进行模块化开发

而模块化的核心是导出与导入，在`Node`中通过`exports`与`module.exports`负责对模块中的内容进行导出，通过`require`函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容

### 二、查找策略

`require`方法接收一下几种参数的传递：

- 原生模块：http、fs、path等
- 相对路径的文件模块：./mod或../mod
- 绝对路径的文件模块：/pathtomodule/mod
- 目录作为模块：./dirname
- 非原生模块的文件模块：mod

`require`参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：

[![img](https://camo.githubusercontent.com/ed2f3f5545812831870c5e3d94ad0d9f706e382945da8ed940c39218ce79c93d/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336165386566302d633962612d313165622d383566362d3666616337376330633962332e706e67)](https://camo.githubusercontent.com/ed2f3f5545812831870c5e3d94ad0d9f706e382945da8ed940c39218ce79c93d/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336165386566302d633962612d313165622d383566362d3666616337376330633962332e706e67)

从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块

#### 原生模块

而像原生模块这些，通过`require `方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载

#### 绝对路径、相对路径

如果`require`绝对路径的文件，则直接查找对应的路径，速度最快

相对路径的模块则相对于当前调用`require`的文件去查找

如果按确切的文件名没有找到模块，则 `NodeJs` 会尝试带上 `.js`、`.json `或 `.node `拓展名再加载

#### 目录作为模块

默认情况是根据根目录中`package.json`文件的`main`来指定目录模块，如：

```
{ "name" : "some-library",
  "main" : "main.js" }
```

如果这是在`./some-library node_modules`目录中，则 `require('./some-library')` 会试图加载 `./some-library/main.js`

如果目录里没有 `package.json`文件，或者 `main`入口不存在或无法解析，则会试图加载目录下的 `index.js` 或 `index.node` 文件

#### 非原生模块

在每个文件中都存在`module.paths`，表示模块的搜索路径，`require`就是根据其来寻找文件

在`window`下输出如下：

```
[ 'c:\\nodejs\\node_modules',
'c:\\node_modules' ]
```

可以看出`module path`的生成规则为：从当前文件目录开始查找`node_modules`目录；然后依次进入父目录，查找父目录下的`node_modules`目录，依次迭代，直到根目录下的`node_modules`目录

当都找不到的时候，则会从系统`NODE_PATH`环境变量查找

#### 举个例子：

如果在`/home/ry/projects/foo.js`文件里调用了 `require('bar.js')`，则 Node.js 会按以下顺序查找：

- /home/ry/projects/node_modules/bar.js
- /home/ry/node_modules/bar.js
- /home/node_modules/bar.js
- /node_modules/bar.js

这使得程序本地化它们的依赖，避免它们产生冲突

### exports.xxx=xxx 和 Module.exports={}有什么区别

```
exports` 其实就是 `module.exports
// module.exports vs exports
// 很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：

// 方法一：对module.exports赋值：

// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

module.exports = {
    hello: hello,
    greet: greet
};

// 方法二：直接使用exports：

// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

function hello() {
    console.log('Hello, world!');
}

exports.hello = hello;
exports.greet = greet;

// 但是你不可以直接对exports赋值：

// 代码可以执行，但是模块并没有输出任何变量:
exports = {
    hello: hello,
    greet: greet
};

// 如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：

// 首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量：

var module = {
    id: 'hello',
    exports: {}
};

// load()函数最终返回module.exports：

var load = function (exports, module) {
    // hello.js的文件内容
    ...
    // load函数返回:
    return module.exports;
};

var exportes = load(module.exports, module);

// 也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象{}，于是，我们可以写：

exports.foo = function () { return 'foo'; };
exports.bar = function () { return 'bar'; };

// 也可以写：

module.exports.foo = function () { return 'foo'; };
module.exports.bar = function () { return 'bar'; };

// 换句话说，Node默认给你准备了一个空对象{}，这样你可以直接往里面加东西。

// 但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值：

module.exports = function () { return 'foo'; };

// 给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。

// 结论

// 如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，并继续在上面添加新的键值；
// 如果要输出一个函数或数组，必须直接对module.exports对象赋值。
// 所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：

module.exports = {
    foo: function () { return 'foo'; }
};

// 或者：

module.exports = function () { return 'foo'; };

// 最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。
```

###  CommonJS与ES6 Modules规范的区别

😂，我相信很多人就比较关心它两区别的问题，因为基本上面试问的就是这个。好吧，这里来做一个算是比较详细的总结吧。

- CommonJS模块是运行时加载，ES6 Modules是编译时输出接口
- CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变
- CommonJs导入的模块路径可以是一个表达式，因为它使用的是`require()`方法；而ES6 Modules只能是字符串
- CommonJS `this`指向当前模块，ES6 Modules `this`指向`undefined`
- 且ES6 Modules中没有这些顶层变量：`arguments`、`require`、`module`、`exports`、`__filename`、`__dirname`

关于第一个差异，是因为CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### 三、总结

通过上面模块的文件查找策略之后，总结下文件查找的优先级：

- 缓存的模块优先级最高
- 如果是内置模块，则直接返回，优先级仅次缓存的模块
- 如果是绝对路径 / 开头，则从根目录找
- 如果是相对路径 ./开头，则从当前require文件相对位置找
- 如果文件没有携带后缀，先从js、json、node按顺序查找
- 如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js
- 如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录

## 4.10 Node中间件

### 一、是什么

中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的

在`NodeJS`中，中间件主要是指封装`http`请求细节处理的方法

例如在`express`、`koa`等`web`框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数

[![img](https://camo.githubusercontent.com/08f52777011cc53112d7c8455083457a273e3a925327cfbeab5298d532e86858/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36613665643366302d636365342d313165622d383566362d3666616337376330633962332e706e67)](https://camo.githubusercontent.com/08f52777011cc53112d7c8455083457a273e3a925327cfbeab5298d532e86858/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36613665643366302d636365342d313165622d383566362d3666616337376330633962332e706e67)

在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作

### 二、封装

`koa`是基于`NodeJS`当前比较流行的`web`框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 `Koa` 应用

`Koa` 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：

- ctx ：封装了request 和  response 的变量
- next ：进入下一个要执行的中间件的函数

[![img](https://camo.githubusercontent.com/0eeb391ad0bdcd470430bafd09e39cb30f50519228a28fdffaa0a1b06cbf3e92/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353037623032302d636365342d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/0eeb391ad0bdcd470430bafd09e39cb30f50519228a28fdffaa0a1b06cbf3e92/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353037623032302d636365342d313165622d616239302d6439616538313462323430642e706e67)

下面就针对`koa`进行中间件的封装：

`Koa `的中间件就是函数，可以是` async` 函数，或是普通函数

```
// async 函数
app.use(async (ctx, next) => {
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
});

// 普通函数
app.use((ctx, next) => {
  const start = Date.now();
  return next().then(() => {
    const ms = Date.now() - start;
    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
  });
});
```

下面则通过中间件封装`http`请求过程中几个常用的功能：

#### token校验

```
module.exports = (options) => async (ctx, next) {
  try {
    // 获取 token
    const token = ctx.header.authorization
    if (token) {
      try {
          // verify 函数验证 token，并获取用户相关信息
          await verify(token)
      } catch (err) {
        console.log(err)
      }
    }
    // 进入下一个中间件
    await next()
  } catch (err) {
    console.log(err)
  }
}
```

#### 日志模块

```
const fs = require('fs')
module.exports = (options) => async (ctx, next) => {
  const startTime = Date.now()
  const requestTime = new Date()
  await next()
  const ms = Date.now() - startTime;
  let logout = `${ctx.request.ip} -- ${requestTime} -- ${ctx.method} -- ${ctx.url} -- ${ms}ms`;
  // 输出日志文件
  fs.appendFileSync('./log.txt', logout + '\n')
}
```

`Koa`存在很多第三方的中间件，如`koa-bodyparser`、`koa-static`等

下面再来看看它们的大体的简单实现：

#### koa-bodyparser

`koa-bodyparser` 中间件是将我们的 `post` 请求和表单提交的查询字符串转换成对象，并挂在 `ctx.request.body` 上，方便我们在其他中间件或接口处取值

```
// 文件：my-koa-bodyparser.js
const querystring = require("querystring");

module.exports = function bodyParser() {
    return async (ctx, next) => {
        await new Promise((resolve, reject) => {
            // 存储数据的数组
            let dataArr = [];

            // 接收数据
            ctx.req.on("data", data => dataArr.push(data));

            // 整合数据并使用 Promise 成功
            ctx.req.on("end", () => {
                // 获取请求数据的类型 json 或表单
                let contentType = ctx.get("Content-Type");

                // 获取数据 Buffer 格式
                let data = Buffer.concat(dataArr).toString();

                if (contentType === "application/x-www-form-urlencoded") {
                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
                    ctx.request.body = querystring.parse(data);
                } else if (contentType === "applaction/json") {
                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
                    ctx.request.body = JSON.parse(data);
                }

                // 执行成功的回调
                resolve();
            });
        });

        // 继续向下执行
        await next();
    };
};
```

#### koa-static

`koa-static` 中间件的作用是在服务器接到请求时，帮我们处理静态文件

```
const fs = require("fs");
const path = require("path");
const mime = require("mime");
const { promisify } = require("util");

// 将 stat 和 access 转换成 Promise
const stat = promisify(fs.stat);
const access = promisify(fs.access)

module.exports = function (dir) {
    return async (ctx, next) => {
        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /
        let realPath = path.join(dir, ctx.path);

        try {
            // 获取 stat 对象
            let statObj = await stat(realPath);

            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html
            if (statObj.isFile()) {
                ctx.set("Content-Type", `${mime.getType()};charset=utf8`);
                ctx.body = fs.createReadStream(realPath);
            } else {
                let filename = path.join(realPath, "index.html");

                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理
                await access(filename);

                // 存在设置文件类型并响应内容
                ctx.set("Content-Type", "text/html;charset=utf8");
                ctx.body = fs.createReadStream(filename);
            }
        } catch (e) {
            await next();
        }
    }
}
```

### 三、总结

在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据

`koa`本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得`web`应用具备良好的可拓展性和组合性

通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式



## 4.11 JWT鉴权机制

### 一、是什么

JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息

[![img](https://camo.githubusercontent.com/a967b716ac30c068693895edd884a6fd819e84ff42d0bfb65083918ec45985f2/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30353239303463302d636438392d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/a967b716ac30c068693895edd884a6fd819e84ff42d0bfb65083918ec45985f2/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30353239303463302d636438392d313165622d616239302d6439616538313462323430642e706e67)

在目前前后端分离的开发过程中，使用`token`鉴权机制用于身份验证是最常见的方案，流程如下：

- 服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证
- 后续访问会根据这个令牌判断用户时候有权限进行访问

`Token`，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以`.`进行拼接。其中头部和载荷都是以`JSON`格式存放数据，只是进行了编码

[![img](https://camo.githubusercontent.com/9d4fdea81db89a5b3bd065b02b08b17c0e0b7510b4f2cc9fc780a71cb9218c35/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313735663939302d636438392d313165622d383566362d3666616337376330633962332e706e67)](https://camo.githubusercontent.com/9d4fdea81db89a5b3bd065b02b08b17c0e0b7510b4f2cc9fc780a71cb9218c35/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313735663939302d636438392d313165622d383566362d3666616337376330633962332e706e67)

#### header

每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为`alg`，同时还有一个`typ`的字段，默认`JWT`即可。以下示例中算法为HS256

```
{  "alg": "HS256",  "typ": "JWT" } 
```

因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        
```

#### payload

载荷即消息体，这里会存放实际的内容，也就是`Token`的数据声明，例如用户的`id`和`name`，默认情况下也会携带令牌的签发时间`iat`，通过还可以设置过期时间，如下：

```
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```

同样进行Base64编码后，字符串如下：

```
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
```

#### Signature

签名是对头部和载荷内容进行签名，一般情况，设置一个`secretKey`，对前两个的结果进行`HMACSHA25`算法，公式如下：

```
Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)
```

一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致

### 二、如何实现

`Token`的使用分成了两部分：

- 生成token：登录成功的时候，颁发token
- 验证token：访问某些资源或者接口时，验证token

#### 生成 token

借助第三方库`jsonwebtoken`，通过`jsonwebtoken` 的 `sign` 方法生成一个 `token`：

- 第一个参数指的是 Payload
- 第二个是秘钥，服务端特有
- 第三个参数是 option，可以定义 token 过期时间

```
const crypto = require("crypto"),
  jwt = require("jsonwebtoken");
// TODO:使用数据库
// 这里应该是用数据库存储，这里只是演示用
let userList = [];

class UserController {
  // 用户登录
  static async login(ctx) {
    const data = ctx.request.body;
    if (!data.name || !data.password) {
      return ctx.body = {
        code: "000002", 
        message: "参数不合法"
      }
    }
    const result = userList.find(item => item.name === data.name && item.password === crypto.createHash('md5').update(data.password).digest('hex'))
    if (result) {
      // 生成token
      const token = jwt.sign(  
        {
          name: result.name
        },
        "test_token", // secret
        { expiresIn: 60 * 60 } // 过期时间：60 * 60 s
      );
      return ctx.body = {
        code: "0",
        message: "登录成功",
        data: {
          token
        }
      };
    } else {
      return ctx.body = {
        code: "000002",
        message: "用户名或密码错误"
      };
    }
  }
}

module.exports = UserController;
```

在前端接收到`token`后，一般情况会通过`localStorage`进行缓存，然后将`token`放到`HTTP `请求头`Authorization` 中，关于`Authorization` 的设置，前面要加上 Bearer ，注意后面带有空格

```
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  config.headers.common['Authorization'] = 'Bearer ' + token; // 留意这里的 Authorization
  return config;
})
```

#### 校验token

使用 `koa-jwt` 中间件进行验证，方式比较简单

```
/ 注意：放在路由前面
app.use(koajwt({
  secret: 'test_token'
}).unless({ // 配置白名单
  path: [/\/api\/register/, /\/api\/login/]
}))
```

- secret 必须和 sign 时候保持一致
- 可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验
- 校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验

获取`token`用户的信息方法如下：

```
router.get('/api/userInfo',async (ctx,next) =>{    const authorization =  ctx.header.authorization // 获取jwt    const token = authorization.replace('Beraer ','')    const result = jwt.verify(token,'test_token')    ctx.body = result
```

注意：上述的`HMA256`加密算法为单秘钥的形式，一旦泄露后果非常的危险

在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌

这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择`RS256`

### 三、优缺点

优点：

- json具有通用性，所以可以跨语言
- 组成简单，字节占用小，便于传输
- 服务端无需保存会话信息，很容易进行水平扩展
- 一处生成，多处使用，可以在分布式系统中，解决单点登录问题
- 可防护CSRF攻击

缺点：

- payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息
- 需要保护好加密密钥，一旦泄露后果不堪设想
- 为避免token被劫持，最好使用https协议

## 4.12 文件上传

### 一、是什么

文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能

因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里

对于文件上传，我们需要设置请求头为`content-type:multipart/form-data`

> multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件

结构如下：

```
POST /t2/upload.do HTTP/1.1
User-Agent: SOHUWapRebot
Accept-Language: zh-cn,zh;q=0.5
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Content-Length: 60408
Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Host: w.sohu.com

--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data; name="city"

Santa colo
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name="desc"
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
 
...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name="pic"; filename="photo.jpg"
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary
 
... binary data of the jpg ...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--
```

`boundary`表示分隔符，如果要上传多个表单项，就要使用`boundary`分割，每个表单项由`———XXX`开始，以`———XXX`结尾

而`xxx`是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现

每个表单项必须包含一个 `Content-Disposition` 头，其他的头信息则为可选项， 比如 `Content-Type`

`Content-Disposition` 包含了 `type `和 一个名字为`name`的 `parameter`，`type` 是 `form-data`，`name `参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 `filename `参数，值就是文件名

```
Content-Disposition: form-data; name="user"; filename="logo.png"
```

至于使用`multipart/form-data`，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高

### 二、如何实现

关于文件的上传的上传，我们可以分成两步骤：

- 文件的上传
- 文件的解析

#### 文件上传

传统前端文件上传的表单结构如下：

```
<form action="http://localhost:8080/api/upload" method="post" enctype="multipart/form-data">
    <input type="file" name="file" id="file" value="" multiple="multiple" />
    <input type="submit" value="提交"/>
</form>
action` 就是我们的提交到的接口，`enctype="multipart/form-data"` 就是指定上传文件格式，`input` 的 `name` 属性一定要等于`file
```

#### 文件解析

在服务器中，这里采用`koa2`中间件的形式解析上传的文件数据，分别有下面两种形式：

- koa-body
- koa-multer

##### koa-body

安装依赖

```
npm install koa-body
```

引入`koa-body`中间件

```
const koaBody = require('koa-body');
app.use(koaBody({
    multipart: true,
    formidable: {
        maxFileSize: 200*1024*1024    // 设置上传文件大小最大限制，默认2M
    }
}));
```

获取上传的文件

```
const file = ctx.request.files.file; // 获取上传文件
```

获取文件数据后，可以通过`fs`模块将文件保存到指定目录

```
router.post('/uploadfile', async (ctx, next) => {
  // 上传单个文件
  const file = ctx.request.files.file; // 获取上传文件
  // 创建可读流
  const reader = fs.createReadStream(file.path);
  let filePath = path.join(__dirname, 'public/upload/') + `/${file.name}`;
  // 创建可写流
  const upStream = fs.createWriteStream(filePath);
  // 可读流通过管道写入可写流
  reader.pipe(upStream);
  return ctx.body = "上传成功！";
});
```

##### koa-multer

安装依赖：

```
npm install koa-multer
```

使用 `multer` 中间件实现文件上传

```
const storage = multer.diskStorage({  destination: (req, file, cb) => {    cb(null, "./upload/")  },  filename: (req, file, cb) => {    cb(null, Date.now() + path.extname(file.originalname))  }})const upload = multer({  storage});const fileRouter = new Router();fileRouter.post("/upload", upload.single('file'), (ctx, next) => {  console.log(ctx.req.file); // 获取文件})app.use(fileRouter.routes());
```

## 4.13 实现分页查询

### 一、是什么

在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示10条数据

[![img](https://camo.githubusercontent.com/61645c8a9031538a690fd08bec5aa2b09a1d55afe089a36d1ba7970aa90ff7c1/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36303730653863302d636631342d313165622d383566362d3666616337376330633962332e706e67)](https://camo.githubusercontent.com/61645c8a9031538a690fd08bec5aa2b09a1d55afe089a36d1ba7970aa90ff7c1/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36303730653863302d636631342d313165622d383566362d3666616337376330633962332e706e67)

要实现分页功能，实际上就是从结果集中显示第1~~10条记录作为第1页，显示第11~~20条记录作为第2页，以此类推

因此，分页实际上就是从结果集中截取出第M~N条记录

### 二、如何实现

前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据

```
{
 "totalCount": 1836,   // 总的条数
 "totalPages": 92,  // 总页数
 "currentPage": 1   // 当前页数
 "data": [     // 当前页的数据
   {
 ...
   }
]
```

后端采用`mysql`作为数据的持久性存储

前端向后端发送目标的页码`page`以及每页显示数据的数量`pageSize`，默认情况每次取10条数据，则每一条数据的起始位置`start`为：

```
const start = (page - 1) * pageSize
```

当确定了`limit`和`start`的值后，就能够确定`SQL`语句：

```
const sql = `SELECT * FROM record limit ${pageSize} OFFSET ${start};`
```

上诉`SQL`语句表达的意思为：截取从`start`到`start`+`pageSize`之间（左闭右开）的数据

关于查询数据总数的`SQL`语句为，`record`为表名：

```
SELECT COUNT(*) FROM record
```

因此后端的处理逻辑为：

- 获取用户参数页码数page和每页显示的数目 pageSize ，其中page 是必须传递的参数，pageSize为可选参数，默认为10
- 编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询
- 查询数据库，返回总数据量、总页数、当前页、当前页数据给前端

代码如下所示：

```
router.all('/api', function (req, res, next) {
  var param = '';
  // 获取参数
  if (req.method == "POST") {
    param = req.body;
  } else {
    param = req.query || req.params;
  }
  if (param.page == '' || param.page == null || param.page == undefined) {
    res.end(JSON.stringify({ msg: '请传入参数page', status: '102' }));
    return;
  }
  const pageSize = param.pageSize || 10;
  const start = (param.page - 1) * pageSize;
  const sql = `SELECT * FROM record limit ${pageSize} OFFSET ${start};`
  pool.getConnection(function (err, connection) {
    if (err) throw err;
    connection.query(sql, function (err, results) {
      connection.release();
      if (err) {
        throw err
      } else {
        // 计算总页数
        var allCount = results[0][0]['COUNT(*)'];
        var allPage = parseInt(allCount) / 20;
        var pageStr = allPage.toString();
        // 不能被整除
        if (pageStr.indexOf('.') > 0) {
          allPage = parseInt(pageStr.split('.')[0]) + 1;
        }
        var list = results[1];
        res.end(JSON.stringify({ msg: '操作成功', status: '200', totalPages: allPage, currentPage: param.page, totalCount: allCount, data: list }));
      }
    })
  })
});
```

### 三、总结

通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量`pageSize`，然后根据当前页的索引`pageIndex`（从1开始），确定`LIMIT`和`OFFSET`应该设定的值：

- LIMIT 总是设定为 pageSize
- OFFSET 计算公式为 pageSize * (pageIndex - 1)

确定了这两个值，就能查询出第 `N`页的数据

## 4.14 Node性能优化

### 一、 是什么

`Node`作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：

- CPU
- 内存
- I/O
- 网络

#### CPU

主要分成了两部分：

- CPU负载：在某个时间段内，占用以及等待CPU的进程总数
- CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) / CPU总时间

这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标

`Node`应用一般不会消耗很多的`CPU`，如果`CPU`占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞

#### 内存指标

内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标

```
// /app/lib/memory.js
const os = require('os');
// 获取当前Node内存堆栈情况
const { rss, heapUsed, heapTotal } = process.memoryUsage();
// 获取系统空闲内存
const sysFree = os.freemem();
// 获取系统总内存
const sysTotal = os.totalmem();

module.exports = {
  memory: () => {
    return {
      sys: 1 - sysFree / sysTotal,  // 系统内存占用率
      heap: heapUsed / headTotal,   // Node堆内存占用率
      node: rss / sysTotal,         // Node占用系统内存的比例
    }
  }
}
```

- rss：表示node进程占用的内存总量。
- heapTotal：表示堆内存的总量。
- heapUsed：实际堆内存的使用量。
- external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量

在`Node`中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露

#### 磁盘 I/O

硬盘的` IO` 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍

内存 `IO `比磁盘` IO` 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 `redis`、`memcached `等

并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决

### 二、如何监控

关于性能方面的监控，一般情况都需要借助工具来实现

这里采用`Easy-Monitor 2.0`，其是轻量级的 `Node.js` 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 `require` 一次，无需改动任何业务代码即可开启内核级别的性能监控分析

使用方法如下：

在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：

```
const easyMonitor = require('easy-monitor');
easyMonitor('你的项目名称');
```

打开你的浏览器，访问 `http://localhost:12333` ，即可看到进程界面

关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档

### 三、如何优化

关于`Node`的性能优化的方式有：

- 使用最新版本Node.js
- 正确使用流 Stream
- 代码层面优化
- 内存管理优化

#### 使用最新版本Node.js

每个版本的性能提升主要来自于两个方面：

- V8 的版本更新
- Node.js 内部代码的更新优化

#### 正确使用流 Stream

在`Node`中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存

```
const http = require('http');
const fs = require('fs');

// bad
http.createServer(function (req, res) {
    fs.readFile(__dirname + '/data.txt', function (err, data) {
        res.end(data);
    });
});

// good
http.createServer(function (req, res) {
    const stream = fs.createReadStream(__dirname + '/data.txt');
    stream.pipe(res);
});
```

#### 代码层面优化

合并查询，将多次查询合并一次，减少数据库的查询次数

```
// bad
for user_id in userIds 
     let account = user_account.findOne(user_id)

// good
const user_account_map = {}   // 注意这个对象将会消耗大量内存。
user_account.find(user_id in user_ids).forEach(account){
    user_account_map[account.user_id] =  account
}
for user_id in userIds 
    var account = user_account_map[user_id]
```

#### 内存管理优化

在 V8 中，主要将内存分为新生代和老生代两代：

- 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象
- 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象

若新生代内存空间不够，直接分配到老生代

通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低

如下面情况：

```
const buffer = fs.readFileSync(__dirname + '/source/index.htm');

app.use(
    mount('/', async (ctx) => {
        ctx.status = 200;
        ctx.type = 'html';
        ctx.body = buffer;
        leak.push(fs.readFileSync(__dirname + '/source/index.htm'));
    })
);

const leak = [];
```

`leak`的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一

而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作

例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动

使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能

# 浏览器

## 5.1 cookie、sessionStorage、loacalStorage

**共同点：都是保存在浏览器端，且同源的。**

**不同点：**

1. cookie数据在浏览器和服务器之间传递，始终在请求中携带，而sessionStorage和localStorage只存在于浏览器，不会把数据发送到服务器。
2. 内存大小不同：cookie不超过4k，sessionStorage和localStorage可以达到5M甚至更大
3. 数据时效不同：cookie在服务器设置的过期时间之前都要效，而sessionStorage只在浏览器窗口关闭之前有效，localStorage始终有效，可以用做持久数据。
4. 作用域不同：sessionStorage只在一个窗口下共享，而cookie和localStorage在所有的同源窗口下共享。
5. sessionStorage和localStorage的api接口使用更方便，并且支持事件通知机制。

## [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#cookie-session-登录) Cookie + Session 登录

> HTTP  是一种无状态的协议，客户端每次发送请求时，首先要和服务器端建立一个连接，在请求完成后又会断开这个连接。这种方式可以节省传输时占用的连接资源，但同时也存在一个问题：每次请求都是独立的，服务器端无法判断本次请求和上一次请求是否来自同一个用户，进而也就无法判断用户的登录状态。

为了解决 HTTP 无状态的问题，Lou Montulli 在 1994 年的时候，推出了 Cookie。

> Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。

有了 `Cookie` 之后，服务器端就能够获取到客户端传递过来的信息了，如果需要对信息进行验证，还需要通过 `Session`

> 客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个便是 `Session` 对象。

有了 `Cookie` 和 `Session`之后，我们就可以进行登录认证了

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#cookie-session-实现流程) Cookie + Session  实现流程

Cookie + Session 的登录方式是最经典的一种登录方式，现在仍然有大量的企业在使用。

用户首次登录时：

![img](https://s.poetries.work/gitee/2020/08/48.png)

- 用户访问 `a.com/pageA`，并输入密码登录。
- 服务器验证密码无误后，会创建 `SessionId`，并将它保存起来。
- 服务器端响应这个 HTTP 请求，并通过 `Set-Cookie` 头信息，将 `SessionId` 写入 `Cookie` 中

> 服务器端的 `SessionId` 可能存放在很多地方，例如：内存、文件、数据库等。

第一次登录完成之后，后续的访问就可以直接使用 Cookie 进行身份验证了：

![img](https://s.poetries.work/gitee/2020/08/49.png)

- 用户访问 `a.com/pageB` 页面时，会自动带上第一次登录时写入的 `Cookie`。
- 服务器端比对 `Cookie` 中的 `SessionId` 和保存在服务器端的 `SessionId` 是否一致。
- 如果一致，则身份验证成功

**Cookie + Session  存在的问题**

> 虽然我们使用 `Cookie + Session`的方式完成了登录验证，但仍然存在一些问题：

- 由于服务器端需要对接大量的客户端，也就需要存放大量的 `SessionId`，这样会导致服务器压力过大。
- 如果服务器端是一个集群，为了同步登录态，需要将 `SessionId` 同步到每一台机器上，无形中增加了服务器端维护成本。
- 由于 `SessionId` 存放在 `Cookie` 中，所以无法避免 `CSRF` 攻击

## [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#token-登录) Token 登录

为了解决 Session + Cookie 机制暴露出的诸多问题，我们可以使用 Token 的登录方式。

> Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#token-机制实现流程) Token 机制实现流程

用户首次登录时：

![img](https://s.poetries.work/gitee/2020/08/50.png)

- 用户输入账号密码，并点击登录。
- 服务器端验证账号密码无误，创建 Token。
- 服务器端将 Token 返回给客户端，由***客户端自由保存***

后续页面访问时：

![img](https://s.poetries.work/gitee/2020/08/51.png)

- 用户访问 `a.com/pageB` 时，带上第一次登录时获取的 `Token`。
- 服务器端验证 `Token` ，有效则身份验证成功

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#token-机制的特点) Token 机制的特点

- 服务器端不需要存放 Token，所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本。
- Token 可以存放在前端任何地方，可以不用保存在 Cookie 中，提升了页面的安全性。
- Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端想收回此 Token 的权限，并不容易。

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#token-的生成方式) Token 的生成方式

> 最常见的 Token 生成方式是使用 JWT（Json Web Token），它是一种简洁的，自包含的方法用于通信双方之间以 JSON 对象的形式安全的传递信息。

上文中我们说到，使用 Token 后，服务器端并不会存储 Token，那怎么判断客户端发过来的 Token 是合法有效的呢？

答案其实就在 Token 字符串中，其实 Token 并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串，我们来具体分析一下。

JWT 算法主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）。

header 部分指定了该 JWT 使用的签名算法:

```text
header = '{"alg":"HS256","typ":"JWT"}'   //
`HS256` 表示使用了 HMAC-SHA256 来生成签名。
```

playload 部分表明了 JWT 的意图：

```text
payload = '{"loggedInAs":"admin","iat":1422779638}'     //iat 表示令牌生成的时间
```

> `signature` 部分为 `JWT` 的签名，主要为了让 `JWT`不能被随意篡改，签名的方法分为两个步骤：

- 输入 `base64url` 编码的 `header` 部分、 . `、base64url` 编码的 `playload` 部分，输出 `unsignedToken`
- 输入 `base64url` 编码的 header 部分、 . 、base64url 编码的 playload 部分，输出 `unsignedToken`

```text
const base64Header = encodeBase64(header)
const base64Payload = encodeBase64(payload)
const unsignedToken = `${base64Header}.${base64Payload}`
const key = '服务器私钥'

signature = HMAC(key, unsignedToken)
```

最后的 Token 计算如下：

```js
const base64Header = encodeBase64(header)
const base64Payload = encodeBase64(payload)
const base64Signature = encodeBase64(signature)

token = `${base64Header}.${base64Payload}.${base64Signature}`
```

服务器在判断 `Token` 时：

```js
const [base64Header, base64Payload, base64Signature] = token.split('.')

const signature1 = decodeBase64(base64Signature)
const unsignedToken = `${base64Header}.${base64Payload}`
const signature2 = HMAC('服务器私钥', unsignedToken)

if(signature1 === signature2) {
  return '签名验证成功，token 没有被篡改'
}

const payload =  decodeBase64(base64Payload)
if(new Date() - payload.iat < 'token 有效期'){
  return 'token 有效'
}
```

> 有了 `Token` 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。

## [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#sso-单点登录) SSO 单点登录

单点登录指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登录都可以在认证中心里完成，一个产品在认证中心登录后，再去访问另一个产品，可以不用再次登录，即可获取登录状态。

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#sso-机制实现流程) SSO 机制实现流程

用户首次访问时，需要在认证中心登录：

![img](https://s.poetries.work/gitee/2020/08/52.png)

- 用户访问网站  `a.com` 下的 `pageA`页面。
- 由于没有登录，则会重定向到认证中心，并带上回调地址 `www.sso.com?return_uri=a.com/pageA`，以便登录后直接进入对应页面。
- 用户在认证中心输入账号密码，提交登录。
- 认证中心验证账号密码有效，然后重定向  `a.com?ticket=123` 带上授权码 `ticket`，并将认证中心 `sso.com` 的登录态写入 `Cookie`。
- 在 a.com 服务器中，拿着 ticket 向认证中心确认，授权码 ticket 真实有效。
- 验证成功后，服务器将登录信息写入 Cookie（此时客户端有 2 个 Cookie 分别存有 a.com 和 sso.com 的登录态）

> 认证中心登录完成之后，继续访问 a.com 下的其他页面：

![img](https://s.poetries.work/gitee/2020/08/53.png)

- 这个时候，由于 a.com 存在已登录的 Cookie 信息，所以服务器端直接认证成功。
- 如果认证中心登录完成之后，访问 b.com 下的页面：

![img](https://s.poetries.work/gitee/2020/08/54.png)

这个时候，由于认证中心存在之前登录过的 `Cookie`，所以也不用再次输入账号密码，直接返回第 4 步，下发 `ticket` 给 `b.com` 即可

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#sso-单点登录退出) SSO 单点登录退出

> 目前我们已经完成了单点登录，在同一套认证中心的管理下，多个产品可以共享登录态。现在我们需要考虑退出了，即：在一个产品中退出了登录，怎么让其他的产品也都退出登录？

原理其实不难，可以回过头来看第 5 步，每一个产品在向认证中心验证 ticket 时，其实可以顺带将自己的退出登录 api 发送到认证中心。

**当某个产品 c.com 退出登录时：**

- 清空 c.com 中的登录态 Cookie。
- 请求认证中心 sso.com 中的退出 api。
- 认证中心遍历下发过 ticket 的所有产品，并调用对应的退出 api，完成退出

## [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#oauth-第三方登录) OAuth 第三方登录

在上文中，我们使用单点登录完成了多产品的登录态共享，但都是建立在一套统一的认证中心下，对于一些小型企业，未免太麻烦，有没有一种登录能够做到开箱即用？

其实是有的，很多大厂都会提供自己的第三方登录服务，我们一起来分析一下。

![img](https://s.poetries.work/gitee/2020/08/55.png)

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#oauth-机制实现流程) OAuth 机制实现流程

这里以微信开放平台的接入流程为例：

![img](https://s.poetries.work/gitee/2020/08/56.png)

- 首先，a.com 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。
- 申请成功后，得到申请的 appid、appsecret。
- 用户在 a.com 上选择使用微信登录。
- 这时会跳转微信的 OAuth 授权登录，并带上 a.com 的回调地址。
- 用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。
- 授权之后，微信会根据拉起 a.com?code=123 ，这时带上了一个临时票据 code。
- 获取 code 之后， a.com 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。
- 有了 token 之后， a.com 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。
- a.com 提示用户登录成功，并将登录状态写入 Cooke，以作为后续访问的凭证。

## [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/comprehensive/-前端登录方案.html#总结) 总结

本文介绍了 4 种常见的登录方式，原理应该大家都清楚了，总结一下这 4 种方案的使用场景：

- `Cookie + Session` 历史悠久，适合于简单的后端架构，需开发人员自己处理好安全问题。
- `Token` 方案对后端压力小，适合大型分布式的后端架构，但已分发出去的 token ，如果想收回权限，就不是很方便了。
- `SSO` 单点登录，适用于中大型企业，想要统一内部所有产品的登录方式。
- `OAuth` 第三方登录，简单易用，对用户和开发者都友好，但第三方平台很多，需要选择合适自己的第三方登录平台。

## 5.2 浏览器输入URL发生了什么

### 输入URL请求资源的过程

![image-20220307102954508](images\image-20220307102954508.png)

1. 浏览器从URL中解析出服务器的主机名；
2. 浏览器从DNS（Domain Name System）获得主机名对应的服务器的IP地址；
3. 浏览器将端口后从URL解析出来（或者有默认端口，则没有显示）；
4. 浏览器建立一条与Web服务器的TCP连接；
5. 浏览器想服务器发送一条HTTP请求报文；
6. 服务器接收到HTTP请求报文，通过路由为请求调用正确的处理程序
7. 处理程序根据请求，查询数据库，实现一些业务逻辑，将获得的页面和数据封装到响应报文的响应体重。
8. 发送响应报文，处理完一切事物后记录日志文件。
9. **关闭连接，浏览器收到数据开始渲染；******

### 浏览器解析过程

1. **浏览器如何渲染网页**

   **概述：浏览器渲染一共有五步**

   1. 处理 `HTML` 并构建 `DOM` 树。
   2. 处理 `CSS`构建 `CSSOM` 树。
   3. 将 `DOM` 与 `CSSOM` 合并成一个渲染树。
   4. 根据渲染树来布局，计算每个节点的位置。
   5. 调用 `GPU` 绘制，合成图层，显示在屏幕上

   > 第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染

   具体如下图过程如下图所示

   ![img](https://s.poetries.work/gitee/2019/10/19.png)

   ![img](https://s.poetries.work/gitee/2019/10/20.png)

   **渲染**

   - 网页生成的时候，至少会渲染一次
   - 在用户访问的过程中，还会不断重新渲染

   > 重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)

   - 在构建 `CSSOM` 树时，会阻塞渲染，直至 `CSSOM`树构建完成。并且构建 `CSSOM` 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 `CSS` 选择器，执行速度越慢
   - 当 `HTML` 解析到 `script` 标签时，会暂停构建 `DOM`，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 `JS` 文件。并且`CSS`也会影响 `JS` 的执行，只有当解析完样式表才会执行 `JS`，所以也可以认为这种情况下，`CSS` 也会暂停构建 `DOM`

   **2. 浏览器渲染五个阶段**

   **2.1 第一步：解析HTML标签，构建DOM树**

   > 在这个阶段，引擎开始解析`html`，解析出来的结果会成为一棵`dom`树 `dom`的目的至少有`2`个

   - 作为下个阶段渲染树状图的输入
   - 成为网页和脚本的交互界面。(最常用的就是`getElementById`等等)

   **当解析器到达script标签的时候，发生下面四件事情**

   1. `html`解析器停止解析,
   2. 如果是外部脚本，就从外部网络获取脚本代码
   3. 将控制权交给`js`引擎，执行`js`代码
   4. 恢复`html`解析器的控制权

   > 由此可以得到第一个结论1

   - 由于`<script>`标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。
   - `defer`和`async`属性也能有助于加载外部脚本。
   - `defer`使得脚本会在`dom`完整构建之后执行；
   - `async`标签使得脚本只有在完全`available`才执行，并且是以非阻塞的方式进行的

   **2.2 第二步：解析CSS标签，构建CSSOM树**

   - 我们已经看到`html`解析器碰到脚本后会做的事情，接下来我们看下`html`解析器碰到样式表会发生的情况
   - `js`会阻塞解析，因为它会修改文档(`document`)。`css`不会修改文档的结构，如果这样的话，似乎看起来`css`样式不会阻塞浏览器`html`解析。但是事实上 `css`样式表是阻塞的。阻塞是指当`cssom`树建立好之后才会进行下一步的解析渲染

   **通过以下手段可以减轻cssom带来的影响**

   - 将`script`脚本放在页面底部
   - 尽可能快的加载`css`样式表
   - 将样式表按照`media type`和`media query`区分，这样有助于我们将`css`资源标记成非阻塞渲染的资源。
   - 非阻塞的资源还是会被浏览器下载，只是优先级较低

   **2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）**

   ![img](https://s.poetries.work/gitee/2019/10/21.png)

   **2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构**

   > 布局(`layout`)：定位坐标和大小，是否换行，各种`position`, `overflow`, `z-index`属性

   **2.5 调用 GPU 绘制，合成图层，显示在屏幕上**

   > 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制`painting`

2. 绘制各元素。

## 5.3 重排（回流）和重绘

### 重排（回流）

概念：重绘指的是，当我们修改DOM中某些盒子的位置和尺寸时，这些盒子周围的盒子的位置和尺寸也会发生改变，所以布局引擎会重新计算每个盒子在页面上的大小和位置。

**触发时机：一般能改变盒子尺寸和位置的操作都会引起回流**

1. 添加和删除DOM元素
2. 元素的位置和尺寸发生变化（比如边距填充边框高度和宽度的变化）
3. 内容变化，有些元素的尺寸由其内容决定，比如行内元素
4. 浏览器的窗口发生变化
5. 一些获取值的操作，offset-Top、scrollTop、clienTop等操作为了获得最新的值会进行回流。

### 重绘

概念：重绘值得是，在获得所有盒子的布局信息后，绘制每个盒子外观的操作，可以看得出重绘其实是在重排后面执行的。

触发时机：重排的操作，改变盒子外观的操作

1. 颜色的改变
2. 阴影的修改
3. 文本方向的修改

### 减少重排和重绘的方式

1. 在添加DOM元素的时候，可以通过DocumentFragment一次添加
2. 通过将一些CSS样式提取到一个类中，通过改变元素的类，来一次改变所有样式
3. 在设置元素属性时，先将display设置为none，然后设置元素的多个属性，最后将display设置为原来的属性，实现一次重排。
4. 在获取offsetTop、scrollTop、clientTop等元素时通过一个变量存储，减少了获取的次数。

## 5.4 事件循环

定义：JavaScript是异步单线程的，所以为了能够提高CPU的利用率，防止长时间的阻塞。JavaScript通过事件循环机制来安排和任务。

例如，主线程在执行的过程中会将遇到的任务添加到一个事件队列中。而执行任务队列中的任务则是通过循环检测状态和执行需要执行的任务。

而任务可以分为宏任务和微任务，微任务是穿插在宏任务之间的，执行完第一个宏任务之后会执行后面所有的微任务，然后执行第二个宏任务。

​	![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646126589003/DE88DFB52F0F1F3211E88086388C6597)

##  5.5 垃圾回收机制

概念：像C语言这种底层的语言都会提供底层的内存管理接口，例如malloc和free()。而面向对象的高级语言在没有提供这种手动管理内存的接口，而是通过一套垃圾回收机制内管理内存。JavaScript也是如此，在创建变量的时候系统会自动分配内存，在不需要使用变量的时候会自动回收内存。

**垃圾回收的方法：**

1. 引用计数
2. 标记清除

### 引用计数

引用计数法通过计算对象的应用次数来决定是否回收对象的内存，这里的对象包括对象和函数作用域。

比如我new了一个对象，用一个变量指向该对象，那么对象的应用数量就是1。引用计数会随着这种指向的增加而增加，

那么当引用数目为0的时候，就可以回收对象的内存了。

弊端：循环引用的对象无法释放，会造成内存泄漏。

### 标记-清除算法

这个算法把对象不再需要给定义为对象不在可以获得。

算法从根对象开始查找（JavaScript中是全局对象），找到所有从根独享开始可以引用的对象，然后找对这些对象引用的对象。这些对象组成的结构可以看作是一棵树，在树中的对象就是可以找到的对象，不在树中的对象就是不可以找到的对象。释放这些不可以找到的对象。

优点：解决了循环引用

弊端：那些无法从根对象查询的对象都会被清除

## 1 浏览器架构

**单进程浏览器时代**

> 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的

![img](https://s.poetries.work/images/20210415092040.png)

- 缺点
  - 不稳定：一个插件的意外崩溃会引起整个浏览器的崩溃
  - 不流畅：所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行
  - 不安全：可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题
- 以上这些就是当时浏览器的特点，`不稳定，不流畅，而且不安全`

**多进程浏览器时代**

- 由于`进程是相互隔离的`，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题
- JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的
- Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

![img](https://s.poetries.work/images/20210415092356.png)

> 最新的Chrome浏览器包括：`1个浏览器（Browser）主进程`、`1个 GPU 进程`、`1个网络（NetWork）进程`、`多个渲染进程`和`多个插件进程`

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将 `HTML、CSS` 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU进程**。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

### [#](https://interview2.poetries.top/docs/simply.html#_2-javascript单线程模型) 2 JavaScript单线程模型

> JavaScript语言的一大特点就是单线程，也就是说，同一时间只能做一件事，前面的任务没做完，后面的任务只能等着。

**1. 为什么JavaScript是单线程的呢?**

- 这主要与JavaScript用途有关。它的主要用途是与用户互动，以及操作DOM。如果JavaScript是多线程的，会带来很多复杂的问题，假如 JavaScript有A和B两个线程，A线程在DOM节点上添加了内容，B线程删除了这个节点，应该是哪个为准呢?  所以，为了避免复杂性，所以设计成了单线程。
- 虽然 HTML5 提出了Web Worker标准。Web Worker  的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker  线程，将一些任务分配给后者运行。但是子线程完全受主线程控制，且不得操作DOM。所以这个并没有改变JavaScript单线程的本质。一般使用  Web Worker 的场景是代码中有很多计算密集型或高延迟的任务，可以考虑分配给 Worker 线程。
- 但是使用的时候一定要注意，worker 线程是为了让你的程序跑的更快，但是如果 worker 线程和主线程之间通信的时间大于了你不使用worker线程的时间，结果就得不偿失了。

**2. 浏览器内核中线程之间的关系**

- GUI渲染线程和JS引擎线程互斥
  - js是可以操作DOM的，如果在修改这些元素的同时渲染页面（js线程和ui线程同时运行），那么渲染线程前后获得的元素数据可能就不一致了。
- JS阻塞页面加载
  - js如果执行时间过长就会阻塞页面

**3. 浏览器是多进程的优点**

- 默认新开 一个 tab 页面 新建 一个进程,所以单个 tab 页面崩溃不会影响到整个浏览器。
- 第三方插件崩溃也不会影响到整个浏览器。
- 多进程可以充分利用现代 CPU 多核的优势。
- 方便使用沙盒模型隔离插件等进程,提高浏览器的稳定性。

**4. 进程和线程又是什么呢**

进程（process）和线程（thread）是操作系统的基本概念。

- 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。
- 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。

> 由于每个进程至少要做一件事,所以一个进程至少有一个线程。系统会给每个进程分配独立的内存,因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段,数据集,堆等）。

进程可以理解为一个工厂不不同车间，相互独立。线程是车间里的工人，可以自己做自己的事情,也可以相互配合做同一件事情。

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

为了让你更好地理解上述计算过程，我画了下面这张对比图

![img](images/202203011648257.png)

从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

总结来说，进程和线程之间的关系有以下4个特点

**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

我们可以模拟以下场景：

```text
A = 1+2
B = 20/0
C = 7*8
```

我把上述三个表达式稍作修改，在计算B的值的时候，我把表达式的分母改成0，当线程执行到B = 20/0时，由于分母为0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了

**2. 线程之间共享进程中的数据。**

如下图所示，线程之间可以对进程的公共数据进行读写操作。

![img](https://s.poetries.work/images/202203011648255.png)

从上图可以看出，线程1、线程2、线程3分别把执行的结果写入A、B、C中，然后线程2继续从A、B、C中读取数据，用来显示执行结果。

**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**

当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

比如之前的IE浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉

**4. 进程之间的内容相互隔离。**

进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程A写入数据到进程B的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。

**5. 任务队列**

- 单线程就意味着，所有任务都要排队执行，前一个任务结束，才会执行后一个任务。
- 如果一个任务需要执行，但此时JavaScript引擎正在执行其他任务，那么这个任务就需要放到一个队列中进行等待。等到线程空闲时，就可以从这个队列中取出最早加入的任务进行执行（类似于我们去银行排队办理业务，单线程相当于说这家银行只有一个服务窗口，一次只能为一个人服务，后面到的就需要排队，而任务队列就是排队区，先到的就优先服务）

**注意：** 如果当前线程空闲，并且队列为空，那每次加入队列的函数将立即执行。

> 为什么会有任务队列？ 由于 JS 是单线程的，同步执行任务会造成浏览器的阻塞，所以我们将 JS 分成一个又一个的任务，通过不停的循环来执行事件队列中的任务。

### [#](https://interview2.poetries.top/docs/simply.html#_3-chrome-打开一个页面需要启动多少进程-分别有哪些进程) 3 Chrome 打开一个页面需要启动多少进程？分别有哪些进程？

打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；最新的 Chrome  浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

- `浏览器进程`：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- `渲染进程`：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8  都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- `GPU 进程`：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI  界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- `网络进程`：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- `插件进程`：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## **什么是跨域？**

- 概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域

**下面是具体的跨域情况详解**

| URL                                                     | 说明                           | 是否允许通信                           |
| ------------------------------------------------------- | ------------------------------ | -------------------------------------- |
| http://www.a.com/a.js、http://www.a.com/b.js            | 同一域名下                     | 允许                                   |
| http://www.a.com/lab/a.js、http://www.a.com/script/b.js | 同一域名下不同文件夹           | 允许                                   |
| http://www.a.com:8000/a.js、http://www.a.com/b.js       | 同一域名，不同端口             | 不允许                                 |
| http://www.a.com/a.js、https://www.a.com/b.js           | 同一域名，不同协议             | 不允许                                 |
| http://www.a.com/a.js、http://70.32.92.74/b.js          | 域名和域名对应ip               | 不允许                                 |
| http://www.a.com/a.js、http://script.a.com/b.js         | 主域相同，子域不同             | 不允许（cookie这种情况下也不允许访问） |
| http://www.a.com/a.js、http://a.com/b.js                | 同一域名，不同二级域名（同上） | 不允许（cookie这种情况下也不允许访问） |
| http://www.cnblogs.com/a.js、http://www.a.com/b.js      | 不同域名                       | 不允许                                 |

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/browser/-web开发中跨域解决方案.html#一、document-domain跨域) 一、document.domain跨域

------

- 原理：相同主域名不同子域名下的页面，可以设置`document.domain`让它们同域
- 限制：同域`document`提供的是页面间的互操作，需要载入`iframe`页面

> 下面几个域名下的页面都是可以通过`document.domain`跨域互操作的： `http://a.com/foo`, `http://b.a.com/bar`, `http://c.a.com/bar`。 但只能以页面嵌套的方式来进行页面互操作，比如常见的`iframe`方式就可以完成页面嵌套

```javascript
// URL http://a.com/foo
var ifr = document.createElement('iframe');
ifr.src = 'http://b.a.com/bar'; 
ifr.onload = function(){
    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;
    ifrdoc.getElementsById("foo").innerHTML);
};

ifr.style.display = 'none';
document.body.appendChild(ifr);
```

- 上述代码所在的`URL`是`http://a.com/foo`，它对`http://b.a.com/bar`的`DOM`访问要求后者将 `document.domain`往上设置一级

```javascript
// URL http://b.a.com/bar
document.domain = 'a.com'
```

- `document.domain`只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在`Chrome`中给出的错误是这样的

```javascript
Uncaught DOMException: Failed to set the 'domain' property on 'Document': 'baidu.com' is not a suffix of 'b.a.com'
```

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/browser/-web开发中跨域解决方案.html#二、有src的标签) 二、有src的标签

------

- 原理：所有具有`src`属性的`HTML`标签都是可以跨域的，包括`<img>`, `<script>`
- 限制：需要创建一个`DOM`对象，只能用于`GET`方法

> - 在`document.body`中`append`一个具有`src`属性的`HTML`标签， `src`属性值指向的`URL`会以`GET`方法被访问，该访问是可以跨域的
> - 其实样式表的`<link>`标签也是可以跨域的，只要是有`src`或`href`的`HTML`标签都有跨域的能力

- 不同的`HTML`标签发送`HTTP`请求的时机不同，例如`<img>`在更改`src`属性时就会发送请求，而`script`, `iframe`, `link[rel=stylesheet]`只有在添加到`DOM`树之后才会发送`HTTP`请求：

```javascript
var img = new Image();
img.src = 'http://some/picture';        // 发送HTTP请求

var ifr = $('<iframe>', {src: 'http://b.a.com/bar'});
$('body').append(ifr);                  // 发送HTTP请求
```

[#](https://interview2.poetries.top/fe-blog-docs/blog-docs/browser/-web开发中跨域解决方案.html#三、jsonp) 三、JSONP

------

- 原理：`<script>`是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数
- 限制：需要创建一个`DOM`对象并且添加到`DOM`树，只能用于`GET`方法

> `JSONP`利用的是`<script>`可以跨域的特性，跨域`URL`返回的脚本不仅包含数据，还包含一个回调

```javascript
// URL: http://b.a.com/foo
var data = {
    foo: 'bar',
    bar: 'foo'
};
callback(data);
```

- 然后在我们在主站`http://a.com`中，可以这样来跨域获取`http://b.a.com`的数据：

```javascript
// URL: http://a.com/foo
var callback = function(data){
    // 处理跨域请求得到的数据
};
var script = $('<script>', {src: 'http://b.a.com/bar'});
$('body').append(script);
```

- 其实`jQuery`已经封装了`JSONP`的使用，我们可以这样来

```javascript
$.getJSON( "http://b.a.com/bar?callback=callback", function( data ){
    // 处理跨域请求得到的数据
});
```

> `$.getJSON`与`$.get`的区别是前者会把`responseText`转换为`JSON`，而且当`URL`具有`callback`参数时， `jQuery`将会把它解释为一个`JSONP`请求，创建一个`<script>`标签来完成该请求

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/browser/-web开发中跨域解决方案.html#四、navigation-对象) 四、navigation 对象

------

- 原理：`iframe`之间是共享`navigator`对象的，用它来传递信息
- 要求：`IE6/7`

> 有些人注意到了`IE6/7`的一个漏洞：`iframe`之间的`window.navigator`对象是共享的。 我们可以把它作为一个`Messenger`，通过它来传递信息。比如一个简单的委托：

```javascript
// a.com
navigation.onData(){
    // 数据到达的处理函数
}
typeof navigation.getData === 'function' 
    || navigation.getData()
// b.com
navigation.getData = function(){
    $.get('/path/under/b.com')
        .success(function(data){
            typeof navigation.onData === 'function'
                || navigation.onData(data)
        });
}
```

> 与`document.navigator`类似，`window.name`也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递`Hash`（有些人叫锚点），这是因为每次浏览器打开一个`URL`时，`URL`后面的`#xxx`部分会保留下来，那么新的页面可以从这里获得上一个页面的数据

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/browser/-web开发中跨域解决方案.html#五、跨域资源共享（cors）) 五、跨域资源共享（CORS）

------

- 原理：服务器设置`Access-Control-Allow-OriginHTTP`响应头之后，浏览器将会允许跨域请求
- 限制：浏览器需要支持`HTML5`，可以支持`POST`，`PUT`等方法

> 前面提到的跨域手段都是某种意义上的`Hack`， `HTML5`标准中提出的跨域资源共享（`Cross Origin Resource Share`，`CORS`）才是正道。 它支持其他的`HTTP`方法如`PUT`, `POST`等，可以从本质上解决跨域问题。

- 例如，从`http://a.com`要访问`http://b.com`的数据，通常情况下`Chrome`会因跨域请求而报错

```javascript
XMLHttpRequest cannot load http://b.com. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://a.com' is therefore not allowed access
```

- 错误原因是被请求资源没有设置`Access-Control-Allow-Origin`，所以我们在`b.com`的服务器中设置这个响应头字段即可

```javascript
Access-Control-Allow-Origin: *              # 允许所有域名访问，或者
Access-Control-Allow-Origin: http://a.com   # 只允许所有域名访问
```

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/browser/-web开发中跨域解决方案.html#六、window-postmessage) 六、window.postMessage

------

- 原理：`HTML5`允许窗口之间发送消息
- 限制：浏览器需要支持`HTML5`，获取窗口句柄后才能相互通信

> 这是一个安全的跨域通信方法，`postMessage(message,targetOrigin)`也是`HTML5`引入的特性。 可以给任何一个`window`发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个`URL`但不相符，那么该事件不会被分发。看一个普通的使用方式吧

```javascript
// URL: http://a.com/foo
var win = window.open('http://b.com/bar');
win.postMessage('Hello, bar!', 'http://b.com'); 
// URL: http://b.com/bar
window.addEventListener('message',function(event) {
    console.log(event.data);
});
```

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/browser/-web开发中跨域解决方案.html#七、访问控制安全的讨论) 七、访问控制安全的讨论

------

- 在`HTML5`之前，`JSONP`已经成为跨域的事实标准了，`jQuery`都给出了支持。 值得注意的是它只是`Hack`，并没有产生额外的安全问题。 因为`JSONP`要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问
- 跨域的正道还是要使用`HTML5`提供的CORS头字段以及`window.postMessage`， 可以支持`POST`, `PUT`等`HTTP`方法，从机制上解决跨域问题。 值得注意的是`Access-Control-Allow-Origin`头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和`JSONP`是一样的

### 反向代理

学习nginx反向代理的功能及使用方法前，先要了解什么是正向代理和反向代理，以及他们的作用，这对于接下来学习负载均衡十分必要。

一、**正向代理与反向代理**



1．**代理服务器**

代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。 

2．**正向代理**

正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。

如下图1所示，内部服务器Server-A需要与互联网上的服务器 Server-B通信，但是A不希望把自己的内部IP地址和源端口暴露到互联网，以免产生安全隐患。因此A通过代理服务器（设备）Proxy-C，与互联网上的服务器B进行通信。



![img](https://pics7.baidu.com/feed/e824b899a9014c0848cab94736461a017af4f421.jpeg?token=406c0b2b5b444a356a734fe4a32006fa)







3．**反向代理**

反向代理的工作原理是，代理服务器来接受客户端的网络访问连接请求，然后服务器将请求有策略的转发给网络中实际工作的业务服务器，并将从业务服务器处理的结果，返回给网络上发起连接请求的客户端。

反向代理有以下优点：

（1）提高了内部服务器的安全；

（2）加快了对内部服务器的访问速度；

（3）节约了有限的IP资源。

如下图2所示，客户端Client-A想要访问www.tonglaoban.com，访问请求通过地址解析后，发送到IP地址为1.1.1.1：80的代理服务器，通过代理服务器的正向代理以及负载均衡功能，最终的访问请求通过轮询（暂时只讨论轮询的负载均衡）的方式分发到Server-A、Server-B、Server-C。



![img](https://pics6.baidu.com/feed/d043ad4bd11373f0c2560332993253f2faed04f3.jpeg?token=512bc70294423ea997a897f5d3784af4)

#### nginx解决跨域的原理

例如：

- 前端server的域名为：`fe.server.com`
- 后端服务的域名为：`dev.server.com`

现在我在`fe.server.com`对`dev.server.com`发起请求一定会出现跨域。

现在我们只需要启动一个nginx服务器，将`server_name`设置为`fe.server.com`,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回`dev.server.com`。如下面的配置：

```text
server {
        listen       80;
        server_name  fe.server.com;
        location / {
                proxy_pass dev.server.com;
        }
}
```

这样可以完美绕过浏览器的同源策略：`fe.server.com`访问`nginx`的`fe.server.com`属于同源访问，而`nginx`对服务端转发的请求不会触发浏览器的同源策略。

# HTTP

### web基础

#### MIME（Multipurpose Internet Mail Extension）

多用途因特网邮件扩展。

格式：对象类型/子类型(text/html)。

#### URI（Uniform Resource Identifier）

统一资源标识符，包括URL和URN。

##### URL（Uniform Resource Location）

统一资源定位符。

格式：http://yahoo.com/images/logo.gif

包含三个部分：方案（http://)、服务器因特网地址（yahoo.com）、资源位置（/images/logo.gif)

更完整的URL语法：scheme://user:password@host:port/path;params?query#frage

#frage:片段不会被发送到服务器，而是当浏览器获取到服务器返回的数据是，根据#frag显示特定片段。

例如ftp:admin:my_password@ftp.prep.ai.mit.edu/pub/gnu

![image-20220307110752799](images\image-20220307110752799.png)

##### URN（Uniform Resource Name）

可以作为资源的唯一名词，与资源所在地无关。

#### HTTP事物

由请求和相应组成。

#### HTTP方法

- GET（查）
- PUT（增）
- DELETE（删）
- POST（发送）
- HEAD（只发送响应头）

#### HTTP状态码

| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| ---- | ---------------------------------------------- |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

例如200表示请求成功文档返回，302表示重定向，404表示没有找到这个资源。

常用状态码：

200：请求成功，返回资源；

204：请求成功，不返回资源；

206：请求成功，返回部分资源；

301：永久重定向，比如修改书签；

302：临时重定向，不修改书签；

303：临时重定向，下一次请求要用get；

304：和重定向没关系，请求到资源但是不满足条件，比如缓存未过期；

400：请求报文存在语法错误；

401：发送的请求需要进过HTTP认证或者认证失败；

403：发送的请求被服务器拒绝，比如访问权限有问题；

404：服务器找不到请求的资源，比如数据库查库失败；

#### HTTP报文

HTTP报文由三部分组成

- 起始行：说明报文用途，状态。
- 首部字段：每个键值对都是一个首部字段，添加一些描述性的信息（服务器、日期、内容格式、内容长度等）
- 主体：可选，包含数据

#### 输入URL请求资源的过程

![image-20220307102954508](images\image-20220307102954508.png)

1. 浏览器从URL中解析出服务器的主机名；
2. 浏览器从DNS（Domain Name System）获得主机名对应的服务器的IP地址；
3. 浏览器将端口后从URL解析出来（或者有默认端口，则没有显示）；
4. 浏览器建立一条与Web服务器的TCP连接；
5. 浏览器想服务器发送一条HTTP请求报文；
6. 服务器向浏览器回送一套HTTP相应报文；
7. 关闭连接，浏览器收到数据开始渲染；

#### 代理

介于客户端和服务器之间，用于转发请求，转发前可以对请求和响应进行过滤，比如病毒检测，屏蔽黄色网站。

#### 缓存

一种特殊的HTTP代理服务器，用于缓存常用的文档，客户端下次请求是直接从缓存中读取，不必去服务器找，更加快捷。

#### 网关

一种特殊服务器，通常永不将HTTP流量转换成其它协议。

![image-20220307105212316](images\image-20220307105212316.png)

#### 隧道

用于传输加密的安全套接字层（SSL）流量。

![image-20220307105522032](images\image-20220307105522032.png)

#### Agent代理

代表用户发送HTTP请求的客户端程序，例如浏览器，网络爬虫。

#### HTTP协议

##### HTTP

现在主流的协议版本是1.1。

##### HTTPS

HTTPS与HTTP相比，唯一的区别是HTTPS使用了网景的安全套接字协议（SSL），安全套接字协议为HTTP连接提供了端到端的加密机制。

## Web服务器

### 服务器分类

- 可以安装在标准计算机上的服务器软件；
- 专门的服务器设备，安装配置了各种软件；
- 便携式嵌入式服务器，常用于嵌入到打印机等消费设备中；

### Web服务器会做什么

- 建立连接：接受或断开客户端连接；
- 接受请求：从网络中读取HTTP请求报文；
- 处理请求：对请求报文进行解释，然后借助后端程序采取行动；
- 访问资源：访问报文中指定的资源；
- 构建响应：创建带有正确头部的HTTP响应报文；
- 发送响应：将响应回送到客户端；
- 记录事物处理过程：将事物记录打印到日志文件；

![image-20220307155618795](images\image-20220307155618795.png)

## CDN工作原理


内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。


CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。

![img](https://pica.zhimg.com/50/v2-5ba76e77f05b030b5879177bd336928f_720w.jpg?source=1940ef5c)![img](https://pica.zhimg.com/80/v2-5ba76e77f05b030b5879177bd336928f_720w.jpg?source=1940ef5c)


借用阿里云官网的例子，来简单介绍CDN的工作原理。


假设通过CDN加速的域名为`www.a.com`，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：

1. 当终端用户（北京）向`www.a.com`下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。
2. LDNS检查缓存中是否有`www.a.com`的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。
3. 当授权DNS解析`www.a.com`时，返回域名CNAME `www.a.tbcdn.com`



# React

## 8.1 React的概念和特性

React是用于构建用户界面的JavaScript库，提供了UI层面的解决方案。

**React特性**

- jsx语法使得我们可以再JavaScript中直接写html标签，使得代码语义更清晰。
- 单项数据绑定
- 虚拟DOM：在JavaScript
- 声明式编程：声明式编程强调要做什么，而不是如何做，注重表达逻辑而不是定义步骤。
- Components组件复用：一切皆组件，将需要重复的逻辑抽象成可以复用的组件，通过这些组件来构建引用。提高代码复用性和降低代码耦合性，维护更方便。

React的这些特性使得它高校灵活，特别适合开发复杂的单页面应用程序。

## 8.2 虚拟DOM

DOM就是文档对象模型，DOM用一个逻辑树的结构来表示一个文档，文档中的内容与DOM树中的节点一一对应。通过操控DOM，我们可以修改文档的内容和结构。

那么虚拟的DOM，就是一个虚拟的文档对象模型，他不是浏览器固有的，是React提供的用于描述真实DOM的JavaScript对象。虚拟DOM的结构与真实DOM一一对应。

创建虚拟DOM的目的是为了更好的虚拟的节点渲染到视图中。

举个例子，在某次操作中，我需要更新是个DOM节点。浏览器回一次一次的执行更新操作，一共执行十次操作。

而有了虚拟DOM，同样更新是十个DOM节点。数据变化引起的更新操作会先在虚拟DOM上执行，通过Diff算法对比虚拟DOM与真实DOM之间的差异，一次执行有必要的更新，避免了没必要的更新。

这种操作思想有点类似通过创建documentFragment，将需要添加的DOM元素全部添加到Fragment中，然后将documentfragment一次添加到DOM中。

1. state数据
2. JSX模版
3. 生成虚拟DOM（虚拟DOM就是一个JS对象，用它来描述真实DOM)(损耗了性能)[ 'div', {id: 'abc'},[ 'span',0, 'hello world']]
4. 用虚拟DOM生成真实的DOM，来显示

<div id='abc'><span>hello world</span></div>

5. state发生变化
6. 数据+模版生成新的虚拟DOM(极大的提升了性能)[ 'div', {id: 'abc'},[ 'span', 0,' bye bye ' 1]
7. 比较原始虚拟DOM和新的虚拟DOM的区别, 找到区别是span中内容(极大的提升性能)
8. 直接操作DOM，改变span中的内容 

正是这种虚拟DOM机制，使得React在移动端也能执行，移动端中只是把浏览器中的DOM换成了移动端的原生应用。

**虚拟DOM和DOM的区别**

1. 虚拟DOM不会产生重排和重绘
2. 虚拟DOM的总损耗是虚拟DOM的增删改+真实DOM的差异增删改+排版和重绘，而真实DOM是真实DOM的完全增删改+重排和重绘。

**优点：**

1. 简单方便，借助jsx语法Xml的语法直接创建html界面，操作方式比直接操作DOM更方便，而且逻辑清晰，可维护性更好。
2. 性能优异，虚拟DOM避免了不必的DOM更新，重排和重绘。
3. 跨平台，React借助虚拟DOM，封装了一套可以跨平台的html标签，一套代码多段可用。

**缺点：**

1. 首次渲染多了一层虚拟DOM的计算，一般首屏加载稍微慢
2. 在一些性能要求高的应用中用虚拟DOM不能做到极致的性能优化。

## 8.3 生命周期

React的生命周期指的是组件从创建到卸载这个周期过程，主要可以分为三个阶段。

- 创建阶段

- 更新阶段
- 卸载阶段

### 创建阶段

- constructor
- getDerivedStateFromProps
- render
- componentDidMount

#### constructor

在创建实例的过程中自动调用。

在该方法中通过super关键字获得父组件的props，以及初始化自己的state，或者在this上绑定方法。

#### getDrivedStateFromProps（props,prestate)

在每次props和state更新的时候调用，可以通过对比当前props和之前的state来防止无用的更新。

#### render

类组件必须实现的方法，用于渲染虚拟DOM结构。

#### componentDidMount

组件挂载到真实的DOM后执行，通常用来执行事件监听和数据获取操作。

### 更新阶段

- getDrivedStateFromProps
- shouldComponentUpdate
- render
- getSnapshotBeforeUpdate
- componentDidmount

#### shouldComponentUpdate（nextstate,nextprops)

可以用来对比新旧state，和props决定是否更新。比如子组件的state中某个属性是父组件从props传过来的，那么一旦父组件的state更新，子组件的props更新，子组件就会重新渲染，通过对比nextprops和this.props可以避免不必要的更新。

#### getSnapshotBeforeUpdate

该方法在render渲染虚拟DOM之后还没有挂载到真实DOM是调用，

常用于获取组件更新前的一些信息，比如滚动位置之类的。

### 卸载阶段

#### componentWillUnmount

在组件卸载之前执行一些收尾操作，例如清空定时器，清理注册时间。

#### 

[![img](https://camo.githubusercontent.com/14ba70012bcf358b1e4a1ca697b0bc47a21781ffa08e7d705e7da383bde83366/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36366339393963302d643337332d313165622d383566362d3666616337376330633962332e706e67)](https://camo.githubusercontent.com/14ba70012bcf358b1e4a1ca697b0bc47a21781ffa08e7d705e7da383bde83366/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36366339393963302d643337332d313165622d383566362d3666616337376330633962332e706e67)

## state和props

### state

组件的数据来源可以是外部参数props和内部数据状态state，内部数据状态一般在constructor中初始化。

由于react的diff算法需要对比数据变化，所以改变state需要调用函数setstate，传入新的数据，而不能在原来的基础上改。

### props

React的核心思想是组件化，页面会被分隔为一个单独的组件，通过组织和复用这些组件能构成复杂的应用页面。

而React中的组件从概念上来看就是一个函数，可以接受一个参数作为输入值，而这个参数就是props。可以把props理解成外部传入组件内部的数据。

React具有单项数据流的特点，父组件可以通过prop将数据传到子组件中，但是子组件不能修改props，不过可以通过父组件传来的回调函数来修改父组件的数据。

#### 相同的点：

- 都是JavaScript对象

- 都能保存信息
- 都能触发渲染

#### 不同点：

- prop是外部传到组件内部的，state是组件自己拥有的，一般在constructor中初始化。
- props不能修改，组件自己的state自己可以维护修改

### super（）和super（props）

在ES6中，子类是没有自己的this对象的，需要继承父类的this对象然后对其进行加工得到子类。那么构造器中的super代替父类的构造函数，实际相当于将父类原型上的构造器函数在子类对象调用，parent.prototype.constructor.call(this,arg);

所以在子类的constructor中如要要用this对象就必须先调用super，可以给super传入参数用于初始化。

### 类组件

在React中，组件都是继承自React.Component，因此必须在constructor中调用super()调用父类的构造函数，子类才能继承到父类的this对象。

在调用super是一般都会传入props，用于初始化，否则调用this.props为undefined。

## SetState执行机制

组件的显示数据可以由外部参数和内部状态决定，而内部状态就是state。

更改state的数据需要调用setstate函数，如果直接在state对象上修改不会触发render。

因为React的diff算法需要比较新旧state的差异，如果直接在state上修改，state对象的地址并没有改变。如果调用setstate重新传入数据，diff算法发现对象的地址发生了改变就会触发render。

### 更新类型

#### 异步更新

调用setstate后，立即取state，并不是最新的state。此时还没有更新完。

在组件生命周期或者React合成事件中setState是异步的

#### 同步更新

调用setState后立即能取出新的state。

setTimeout或原始DOM事件中是同步。

#### 批量更新

批量的相同的异步更新，只会取最后一个值，其实相当于Object.assign(preState， {index: state.count+ 1},  {index: state.count+ 1},  ...)

```javascript
Object.assign(  previousState,  {index: state.count+ 1},  {index: state.count+ 1},  ...)
```

usState,  {index: state.count+ 1},  {index: state.count+ 1},  ...)

内部会合并相同的更新。



如果后一次更新依赖前一次，可以给Setstate传入函数

```javascript
onClick = () => {    this.setState((prevState, props) => {      return {count: prevState.count + 1};    });    this.setState((prevState, props) => {      return {count: prevState.count + 1};    });}
```

而在同步更新种由于同步操作是按顺序来的，所以批量更新不会出现覆盖。每一次都会执行。

## React事件机制

React基于浏览器的事件机制，实现了一套自己的合成事件机制，包括事件注册、合成、冒泡、派发。

### 合成事件

合成事件是React模拟所有浏览原生事件能力，封装了一套自己的事件，可以实现跨浏览器运行。

### 区别

1. 获取方式，对于合成事件，再组件绑定回调函数，回调函数默认可以取到事件对象。如果要获取原生事件对象，需要e.nativeEvent获取。

```javascript
const handleClick = (e) => console.log(e.nativeEvent);;
const button = <button onClick={handleClick}>按钮</button>
```

2. 命名方式不同，合成事件采用小驼峰命名
3. 处理函数书写不同，合成事件采用大括号，原生事件采用字符串。
4. 绑定位置不同，原生事件绑定在DOM元素中，合成事件采用事件代理方式，将所有事件绑定在最外层的document的对象上。用一个统一的事件监听器去监听，这个事件监听器上有一个映射来保存所有组件的内部事件监听与处理函数。当组件卸载或者挂载的时候，实际上只是在这个时间监听器上插入或删除了一些对象，系统自动帮我们添加和清除事件。

### 执行顺序

React中事件执行的顺序是，document级别以下的原生事件优先，其次是document上的合成事件，最后是document上的原生事件

```javascript
import  React  from 'react';
class App extends React.Component{

  constructor(props) {
    super(props);
    this.parentRef = React.createRef();
    this.childRef = React.createRef();
  }
  componentDidMount() {
    console.log("React componentDidMount！");
    this.parentRef.current?.addEventListener("click", () => {
      console.log("原生事件：父元素 DOM 事件监听！");
    });
    this.childRef.current?.addEventListener("click", () => {
      console.log("原生事件：子元素 DOM 事件监听！");
    });
    document.addEventListener("click", (e) => {
      console.log("原生事件：document DOM 事件监听！");
    });
  }
  parentClickFun = () => {
    console.log("React 事件：父元素事件监听！");
  };
  childClickFun = () => {
    console.log("React 事件：子元素事件监听！");
  };
  render() {
    return (
      <div ref={this.parentRef} onClick={this.parentClickFun}>
        <div ref={this.childRef} onClick={this.childClickFun}>
          分析事件执行顺序
        </div>
      </div>
    );
  }
}
export default App;
```

输出顺序为：

```
原生事件：子元素 DOM 事件监听！ 
原生事件：父元素 DOM 事件监听！ 
React 事件：子元素事件监听！ 
React 事件：父元素事件监听！ 
原生事件：document DOM 事件监听！ 
```

- React 所有事件都挂载在 document 对象上
- 当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件
- 所以会先执行原生事件，然后处理 React 事件
- 最后真正执行 document 上挂载的事件

对应过程如图所示：

[![img](https://camo.githubusercontent.com/fc597d080759b782144a5a53b7617431409d157b94428a1ad5e58406aef722f0/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30386532326666302d643837302d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/fc597d080759b782144a5a53b7617431409d157b94428a1ad5e58406aef722f0/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30386532326666302d643837302d313165622d616239302d6439616538313462323430642e706e67)

所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：

- 阻止合成事件间的冒泡，用e.stopPropagation()
- 阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()
- 阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免

```java
document.body.addEventListener('click', e => {   
    if (e.target && e.target.matches('div.code')) {  
        return;    
    }    
    this.setState({   active: false,    });   }); 
}
```

## 三、总结

`React`事件机制总结如下：

- React 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)
- React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。
- React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback
- React 有一套自己的合成事件 SyntheticEvent

## 事件绑定的四种方式

### 不绑定的后果

在`react`应用中，事件名都是用小驼峰格式进行书写，例如`onclick`要改写成`onClick`

最简单的事件绑定如下：

```javascript
class ShowAlert extends React.Component {
  showAlert() {
    console.log("Hi");
  }

  render() {
    return <button onClick={this.showAlert}>show</button>;
  }
}
```

从上面可以看到，事件绑定的方法需要使用`{}`包住

上述的代码看似没有问题，但是当将处理函数输出代码换成`console.log(this)`的时候，点击按钮，则会发现控制台输出`undefined`

因为在构造函数之外写的函数都会被放到原型对象中，而此处的函数是普通函数，普通函数的this指向调用函数的环境，而在组建中onclick事件触发后

会调用该函数，而调用的对象不是类的实例，可能是一个指向该函数的变量，那么此时通过该变量调用函数，函数是没有this对象的。

```javascript
class  demo {
    constructor(){

    }

    prit(){
        console.log(this);
    }
}

let a = new demo();
let t = a.prit;
t()//undifine
t.call(a);//demo{}
```

### 四种绑定的方式

1. 在构造函数中用bind绑定。
2. 在类中定义式用箭头函数，定义式就默认绑定。
3. 在组件的事件回调用绑定。
4. 在组件的事件回调中，使用箭头函数，此时箭头函数中的this就是实例的this，所以在箭头函数中可以调用需要的函数。

### 区别

1. 构造函数中绑定的话每个函数都要显示的绑定一次代码量大
2. 使用箭头函数在定义时就绑定，比较方便，但是缺点是this不可以更改
3. 在组件的事件回调中用bind绑定，每次render的时候都会进行bind操作影响性能
4. 在回调函数中用箭头函数，每次render的时候都会产生新的匿名函数，浪费性能。

## React组件

### 一、是什么

React的核心思想就是组件化，将应用按照逻辑分解成可以复用的单个组件，通过组合这些组件可以构成不同的应用。

比如我要做一个搜索展示数据的面板，这个面板有输入框，展示区域，和展示区域的表单。那么我可以将整个面板作为最外层的组件

然后内部有搜索部分组件，展示部分组件，展示部分有表头组件，和表单组件。

1. 通过这样的划分，整个面板中的各个部分的逻辑就分开了，降低了系统的耦合度，那么如果我需要增加新的功能（日历，时间），只要在面板中加入新的组件即可。

2. 调试更方便，如果那一部分UI显示有问题，首先从该部分的组件开始排查。
3. 提高可维护性，每个组件功能职责单一，比如表格组件只用于展示数据，那么表格组件的数量随着输入的数据变化。代码复用。

### 二、如何构建

React提供了三种创建组件的方式

1. 函数式组件
2. 类组件

#### 函数组件

创建函数，在return中返回UI

```
function HelloComponent(props, /* context */) {
  return <div>Hello {props.name}</div>
}
```

### 类组件

创建类，继承React.Component类 

在render方法中返回UI。

```
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  tick() {
    this.setState(state => ({
      seconds: state.seconds + 1
    }));
  }

  componentDidMount() {
    this.interval = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  render() {
    return (
      <div>
        Seconds: {this.state.seconds}
      </div>
    );
  }
}
```

### 区别

在没有React hooks的时候，函数组件是无状态组件，只负责根据传入的props展示视图。不涉及state状态操作，没同时也没有生命周期。

而类组件有state状态，Ref引用，生命周期。

但是有了react hooks以后，函数组件也有state，Ref，effect。成为了有状态组件，由于函数组件无需管理this对象，加上目前推崇函数式编程，所以

现在更多的是使用函数组件，在组件的选择原则上，能用无状态的组件就用，无状态组件更利于管理。

函数式组件有利于自动化测试，至于要吧函数给测试工具就可以

## 组件通信

### 概念

组件通信就是指组件之间传递信息。比如在一个组件中输入数据，然后在另一个组件获得数据实现渲染。

### 通信的种类

因为DOM逻辑上是树形的结构，所以组件之间的通信可以分为以下几种。

1. 从上往下传，有父组件到子组件，父组件到后代组件（在子组件的标签内传递，子组件通过props获取）。到后代组件可以通过context传递。
2. 从下往上，子组件到父组件（父组件向子组件传递一个函数，然后通过这个函数的回调拿到子组件传过来的数据）
3. 同级之间传，将同级之间需要的数据放到共同的父组件中，结合子组件和父组件间的传递方式来传递，这叫状态提升。
4. 不在一棵树上，非关系组件之间传递。将数据进行一个全局资源管理，例如使用react-redux；

### 父组件向后代组件传递

父组件向后代组件传递数据是一件最普通的事情，就像全局数据一样

使用`context`提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取对应的数据

通过使用`React.createContext`创建一个`context`

```
 const PriceContext = React.createContext('price')
```

`context`创建成功后，其下存在`Provider`组件用于创建数据源，`Consumer`组件用于接收数据，使用实例如下：

`Provider`组件通过`value`属性用于给后代组件传递数据：

```
<PriceContext.Provider value={100}>
</PriceContext.Provider>
```

如果想要获取`Provider`传递的数据，可以通过`Consumer`组件或者或者使用`contextType`属性接收，对应分别如下：

```
class MyClass extends React.Component {
  static contextType = PriceContext;
  render() {
    let price = this.context;
    /* 基于这个值进行渲染工作 */
  }
}
```

`Consumer`组件：

```
<PriceContext.Consumer>
    { /*这里是一个函数*/ }
    {
        price => <div>price：{price}</div>
    }
</PriceContext.Consumer>
```

**单项数据流最大的好处是简单易回溯，出现错误的时候好查找，就有点类似流水线上的工人吧，自己管自己的这一步**

**还有一点就是，通过props传递的数据可以看作是函数的传参，如果在组件内部可以改变props就相当于在函数内部改变参数，那么向这个函数输入数据会产生副作用，就不是纯函数了，使得函数不可预测执行结果，降低了代码的可维护性。**

## Key

**作用：**用于判断元素是新创建的，还是原来就有的只是改变了位置。Diff算法更具key值减少了不必要的渲染。

注意事项：

1. key应该是唯一的
2. key不要用随机值（随机数每次都会变，会重发渲染）
3. 避免用index，插入头部导致所有都渲染

## refs

### 一、是什么

refs提供了一种访问DOM节点或在render渲染的react元素。

### 二、如何使用

1. 传入字符串：首先在构造函数中声明this.textInput = React.createRef()，然后在需要引用的元素中设置ref='textInput'， 然后可以this.refs.textInput调用该元素
2. 传入对象：this.textInput  = React.createRef()，然后在引用的元素中设置ref={this.textInput}。然后可以通过this.textInput.current;
3. 传入回到函数：this.textInput = null， 然后在引用的元素中设置ref={element=> this.textInput = element} React会在渲染时自动调用绑定，通过this.textInput获得
4. hook：const textinput = useRef()，然后在引用的元素中设置ref={textinput}  通过 textInput.current获得。

注意：ref指向的要么是dom元素要么是react组件的实例，由于函数组件没有实例所以不能使用ref属性。

### 三、应用场景

- 对dom元素焦点的控制，内容选择等，比如设置打开注册页面的时候自动focus到输入框。
- 对dom元素的内容设置以及媒体播放。
- 继承第三方Dom库

## 函数组件和类组件

区别：

1. 编写形式
2. 状态管理
3. 生命周期
4. 调用方式

优缺点：

1. 函数式组件语法更简洁，易用易测试。
2. 类组件会大量用到this，this的管理容易让人困惑。
3. 函数式组件更符合函数式编程
4. 类组件需要创建组件的实例，内存消耗大

## 受控组件和非受控组件

### 受控组件

受控组件就是受编写人员控制的组件，组件的状态响应外部的数据。

比如创建一个input输入框，如果不做别的操作，输入的内容是无法显示的，只会显示初始的数据，input标签是只读状态。

需要人为的设置onChange事件，在事件函数中实现setState更更新数据。也就是说受控组件的数据更新这些所有的操作都是人为控制的，需要人为设置。

### 非受控组件

非受控组件就是不受控制的组件，组件只在初始化的时候接受外部数据，在内部存储器自身状态，数据更新的操作是自身管理的。

使用ref查询DOM来查找当前值。

### 三、应用场景

大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由`React`组件负责处理

如果选择非受控组件的话，控制能力较弱，表单数据就由`DOM`本身处理，但更加方便快捷，代码量少

## 高阶组件

高阶组件概念和高阶函数类似，高阶函数接受一个或多个函数作为输入，输出以个函数。

而高阶组件接受一个或多个组件作为参数，返回一个组件，本质是一个函数，并不是组件。

一般吧通用的逻辑放到高阶组件 中，对组件实现一致的处理，实现代码复用，

比如一个记录渲染时间的高阶组件，传入一个组件返回一个继承自传入组件的组件，在这个组件的componentWillMount函数中记录时间，在componentDidUnmount函数中纪律结束时间，然后打印出时间差。

```
class Home extends React.Component {
    render() {
        return (<h1>Hello World.</h1>);
    }
}
function withTiming(WrappedComponent) {
    return class extends WrappedComponent {
        constructor(props) {
            super(props);
            this.start = 0;
            this.end = 0;
        }
        componentWillMount() {
            super.componentWillMount && super.componentWillMount();
            this.start = Date.now();
        }
        componentDidMount() {
            super.componentDidMount && super.componentDidMount();
            this.end = Date.now();
            console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);
        }
        render() {
            return super.render();
        }
    };
}

export default withTiming(Home);
```

**注意事项:**

props保持一致

不要改变原始组件，避免副作用，保持纯函数。

## hooks

Hook是React16.8新增的特性，hook使得函数组件拥有了类组件相同的功能，比如state，ref，生命周期。

### 引入state的原因：

1. 类组件的声明周期函数常常会把逻辑不关的代码放到一起，只是因为这些代码应该在这个生命周期执行。
2. 类组件中的this管理复杂，增加学习成本，容易出错。
3. 有些业务变动，使得没有状态的函数组件需要改为类组件。
4. 函数组件代码清晰容易维护，而且不需要实例化对象，占用内存少，并且遵循函数式编程的原则，那么给函数组件增加了类组件才有的功能，就可以获得两种组件的优势。

### hooks种类：

2. useState：模拟state；
3. useEffect：模拟生命周期函数，默认在首次和更新调用，传入依赖数组则在数组变化调用，传入空数组只允许一次，回调函数返回的函数相当于在componentwillunmount中。useEffect相当于componentdidunmount, componentDidupdate, componentWillUNmount。
4. useRef：用于获取Dom元素或者React组件的引用；
5. useContext：用于父组件向下传递数据
6. useReducer：useState的替代方案，可以理解成react版本的redux把，传入reducer,initialState返回当前state和dispath方法。
7. useCallback：返回memorized回调函数，传入回调函数和和依赖项数组，只有当依赖项数组发生改变的时候才会更新回调函数。
8. useMemo：返回memorized值，传入函数和依赖项数组，只有当依赖项改变的时候才会重新计算memorized值。在渲染期间执行，可以用来作为性能优化的手段，而不要当做effect函数用。

## React引入css方法

### **在组件内直接使用，设置元素的style属性**

优点是样式之间没有冲突，样式优先级高。

缺点是大量的样式代码增加耦合，造成代码混乱不利于管理，有些样式无法编写（伪类，伪元素）。



### 在组件内引入.css文件



优点是集中管理css代码，降低耦合。

缺点是样式全局有效，相互间有影响。



### 组件中引入.module.css

在组件中引入.module.css，然后将元素的类名写成style.classname

优点是唯一的类名解决了样式间的冲突

缺点是类名不能用连字符（会被当成表达式中的－号）,所有类名必须用style.classname，照着css写一遍。，不方便动态修改，因为类名是唯一的字符串。

## Redux

一、是什么

react是单项数据流的，数据从父组件流向后代主讲，这种单项数据流在后期维护的时候能够通过回溯快速找到数据出错的位置，就像流水线上的工人医院。

但是单项数据流很难实现一下复杂的场景，比如在多个不同的组件之间传递信息。那么这个时候就需将所以的状态集中管理，

![image-20220404100331814](images\image-20220404100331814.png)

**strore的方法**

![image-20220404144656620](images\image-20220404144656620.png)

![image-20220404162206809](images\image-20220404162206809.png)

加入了redux-thunk中间件之后，就可以dispatch函数了，此时dispatch判断传入的action是回调函数，就会帮你调用，这个回调函数可以获取数据然后调用另一个dispatch初始化数据。所以中间件其实是在dispatch和reducer中间的，在这个中间帮你调用函数。没有中间件的时候dispatch只分发传过来的对象给reducer处理。



## Render执行情况

1. state、props发生变化，重新render
2. 子组件是由父组件渲染的时候调动然后渲染的，所以父组件渲染时子组件也会渲染

# webpack

## 传统的js引入方式的弊端

1. 多个script标签按顺序引入，顺序固定不便于扩展。
2. 如果多个script合并一个会有作用域问题，window对象绑定多个对象，导致臃肿。
3. 为了使用某个函数得加载整个.js文件

## 使用webpack

1. 手动命令式打包文件，设置入口出口。
2. 在需要打包的根目录下配置webpack.config.js

```js
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "./dist"),
    clean: true,
  },
  mode: "none",
  plugins: [
    new HtmlWebpackPlugin({
      template: "./index.html",
      filename: "app.html",
      inject: "body",
    }),
  ],
};
```

3. 使用source map 定位代码行
4. 使用--watch命令实现编译时自动检测文件变化然后打包
5. 使用webpack-dev-server实现浏览器自动刷新

## 资源类型

![image-20220422222529909](images\image-20220422222529909.png)

## Loader

![image-20220423131558257](images\image-20220423131558257.png)

## 代码分离（加速首屏加载）

1. 根据入口分离：使用多个入口和多个出口，缺点是会重复引用公共模块。定义公共模块，配置那些入口需要公共模块。解决重复问题。
2. 动态导入，在代码中需要的时候使用ES6import导入。
3. 懒加载(按需加载)，当点击的时候才调用import导入
4. 预获取prefetch，通过魔法注释在动态加载的import出配置预获取模式，当整个页面加载完后，并且空闲时期才下载import的内容。
5. 预加载preloading，与懒加载类似。

## 缓存

将第三方代码打包缓存到浏览器中，避免了不必要的过于请求。方法就是将这些文件打包到一个文件中，这个文件的名字不会更改，所以一直存在缓存中。

## 公共路径

配置公共路径后，index.html中引入的资源都会加上公共路径，一半是部署时的域名（https:localhost:80/）

## 环境配置

通过分别配置开发环境和生产环境的配置，然后在运行时通过指令调用不同的环境配置。

开发环境下不压缩代码，不用hash命名文件名，不用公共路径等功能。

生产环境下为了提高效率需要删除开发环境下的辅助，并且进行资源压缩等。

## npm脚本

在packag.json中配置scripts属性，那么在package.json文件作为的目录下执行配置脚本就会执行，脚本对应的实际命令。

而配置的命令是在当前文件目录下的node_modules中的模块所拥有的命令。

如果你安装了某个模块，但是在node_modules中执行脚本命令发现没有该命令，那么就说明安装的时候这个命令没有配置到package.json中，所以得手动配置。







# npx 使用教程

作者： [阮一峰](https://www.ruanyifeng.com/)

日期： [2019年2月 9日](https://www.ruanyifeng.com/blog/2019/02/)

npm 从5.2版开始，增加了 npx 命令。它有很多用处，本文介绍该命令的主要使用场景。

![img](https://www.wangbase.com/blogimg/asset/201902/bg2019020901.jpg)

Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。

> ```bash
> $ npm install -g npx
> ```

## 调用项目安装的模块

npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 [Mocha](https://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)。

> ```bash
> $ npm install -D mocha
> ```

一般来说，调用 Mocha ，只能在项目脚本和 package.json 的[`scripts`](https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html)字段里面， 如果想在命令行下调用，必须像下面这样。

> ```bash
> # 项目的根目录下执行
> $ node-modules/.bin/mocha --version
> ```

npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。

> ```bash
> $ npx mocha --version
> ```

npx 的原理很简单，就是运行的时候，会到`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在。

由于 npx 会检查环境变量`$PATH`，所以系统命令也可以调用。

> ```bash
> # 等同于 ls
> $ npx ls
> ```

注意，Bash 内置的命令不在`$PATH`里面，所以不能用。比如，`cd`是 Bash 命令，因此就不能用`npx cd`。

## 避免全局安装模块

除了调用项目内部模块，npx 还能避免全局安装的模块。比如，`create-react-app`这个模块是全局安装，npx 可以运行它，而且不进行全局安装。

> ```bash
> $ npx create-react-app my-react-app
> ```

上面代码运行时，npx 将`create-react-app`下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载`create-react-app`。

下载全局模块时，npx 允许指定版本。

> ```bash
> $ npx uglify-js@3.1.0 main.js -o ./dist/main.js
> ```

上面代码指定使用 3.1.0 版本的`uglify-js`压缩脚本。

注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装`http-server`模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。

> ```bash
> $ npx http-server
> ```

## `--no-install` 参数和`--ignore-existing` 参数

如果想让 npx 强制使用本地模块，不下载远程模块，可以使用`--no-install`参数。如果本地不存在该模块，就会报错。

> ```bash
> $ npx --no-install http-server
> ```

反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用`--ignore-existing`参数。比如，本地已经全局安装了`create-react-app`，但还是想使用远程模块，就用这个参数。

> ```bash
> $ npx --ignore-existing create-react-app my-react-app
> ```

## 使用不同版本的 node

利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 [node 模块](https://www.npmjs.com/package/node)。

> ```bash
> $ npx node@0.12.8 -v
> v0.12.8
> ```

上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。

某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。

## `-p` 参数

`-p`参数用于指定 npx 所要安装的模块，所以上一节的命令可以写成下面这样。

> ```bash
> $ npx -p node@0.12.8 node -v 
> v0.12.8
> ```

上面命令先指定安装`node@0.12.8`，然后再执行`node -v`命令。

`-p`参数对于需要安装多个模块的场景很有用。

> ```bash
> $ npx -p lolcatjs -p cowsay [command]
> ```

## -c 参数

如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。

> ```bash
> $ npx -p lolcatjs -p cowsay 'cowsay hello | lolcatjs'
> # 报错
> ```

上面代码中，`cowsay hello | lolcatjs`执行时会报错，原因是第一项`cowsay`由 npx 解释，而第二项命令`localcatjs`由 Shell 解释，但是`lolcatjs`并没有全局安装，所以报错。

`-c`参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了。

> ```bash
> $ npx -p lolcatjs -p cowsay -c 'cowsay hello | lolcatjs'
> ```

`-c`参数的另一个作用，是将环境变量带入所要执行的命令。举例来说，npm 提供当前项目的一些环境变量，可以用下面的命令查看。

> ```bash
> $ npm run env | grep npm_
> ```

`-c`参数可以把这些 npm 的环境变量带入 npx 命令。

> ```bash
> $ npx -c 'echo "$npm_package_name"'
> ```

上面代码会输出当前项目的项目名。

## 执行 GitHub 源码

npx 还可以执行 GitHub 上面的模块源码。

> ```bash
> # 执行 Gist 代码
> $ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
> 
> # 执行仓库代码
> $ npx github:piuccio/cowsay hello
> ```

注意，远程代码必须是一个模块，即必须包含`package.json`和入口脚本。



# webpack原理

## 构建是什么

构建就是做这件事情，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。

- 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。
- 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。
- 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。
- 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。
- 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。
- 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。
- 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。

## 常见的构建工具

- npm script

- grunt
- gulp
- webpack
- vite
- rollup

## Loader

模块转换器，用于把模块原内容按照需求转换成新内容。

Loader 可以看作具有文件转换功能的翻译员，配置里的 `module.rules` 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以 `.css` 结尾的文件时先使用 `css-loader` 读取 CSS 文件，再交给 `style-loader` 把 CSS 内容注入到 JavaScript 里。 在配置 Loader 时需要注意的是：

**给 Loader 传入属性的方式除了有 querystring 外，还可以通过 Object 传入**。

除了在 `webpack.config.js` 配置文件中配置 Loader 外，还可以在源码中指定用什么 Loader 去处理文件。 以加载 CSS 文件为例，修改上面例子中的 `main.js` 如下：

```js
require('style-loader!css-loader?minimize!./main.css');
```

一个 Loader 的职责是单一的，只需要完成一种转换。 如果一个源文件需要经历多步转换才能正常使用，就通过多个 Loader 去转换。 在调用多个 Loader 去转换一个文件时，每个 Loader 会链式的顺序执行， 第一个 Loader 将会拿到需处理的原内容，上一个 Loader 处理后的结果会传给下一个接着处理，最后的 Loader 将处理后的最终结果返回给 Webpack。

所以，在你开发一个 Loader 时，请保持其职责的单一性，你只需关心输入和输出。

## Plugin

扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。

## DevServer

webpack提供的开发服务器，提供HTTP服务、自动刷新、sourcemap。

自动更新的原理是webpack构建的JavaScript代码中注入了一个代理客户端，代理客户端与devserver通过websocket全双工协议通讯，一旦webpack监测带代码变化就会告诉devserver发送更新请求给客户端，客户端刷新获得最新的网页；

## 模块热替换

模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。 模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。

DevServer 默认的行为是在发现源代码被更新后会通过自动刷新整个页面来做到实时预览，开启模块热替换功能后将在不刷新整个页面的情况下通过用新模块替换老模块来做到实时预览。

## SourceMap

源代码映射

## Entry

入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。

## Module

模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。

## **Chunk**

代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。

## Output

输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。

## webpack 执行过程

Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。

## 配置汇总



```json
const path = require('path');

module.exports = {
  // entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。
  // 类型可以是 string | object | array   
  entry: './app/entry', // 只有1个入口，入口只有1个文件
  entry: ['./app/entry1', './app/entry2'], // 只有1个入口，入口有2个文件
  entry: { // 有2个入口
    a: './app/entry-a',
    b: ['./app/entry-b1', './app/entry-b2']
  },

  // 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。
  output: {
    // 输出文件存放的目录，必须是 string 类型的绝对路径。
    path: path.resolve(__dirname, 'dist'),

    // 输出文件的名称
    filename: 'bundle.js', // 完整的名称
    filename: '[name].js', // 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称
    filename: '[chunkhash].js', // 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件

    // 发布到线上的所有资源的 URL 前缀，string 类型
    publicPath: '/assets/', // 放到指定目录下
    publicPath: '', // 放到根目录下
    publicPath: 'https://cdn.example.com/', // 放到 CDN 上去

    // 导出库的名称，string 类型
    // 不填它时，默认输出格式是匿名的立即执行函数
    library: 'MyLibrary',

    // 导出库的类型，枚举类型，默认是 var
    // 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ，
    libraryTarget: 'umd', 

    // 是否包含有用的文件路径信息到生成的代码里去，boolean 类型
    pathinfo: true, 

    // 附加 Chunk 的文件名称
    chunkFilename: '[id].js',
    chunkFilename: '[chunkhash].js',

    // JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用
    jsonpFunction: 'myWebpackJsonp',

    // 生成的 Source Map 文件名称
    sourceMapFilename: '[file].map',

    // 浏览器开发者工具里显示的源码模块名称
    devtoolModuleFilenameTemplate: 'webpack:///[resource-path]',

    // 异步加载跨域的资源时使用的方式
    crossOriginLoading: 'use-credentials',
    crossOriginLoading: 'anonymous',
    crossOriginLoading: false,
  },

  // 配置模块相关
  module: {
    rules: [ // 配置 Loader
      {  
        test: /\.jsx?$/, // 正则匹配命中要使用 Loader 的文件
        include: [ // 只会命中这里面的文件
          path.resolve(__dirname, 'app')
        ],
        exclude: [ // 忽略这里面的文件
          path.resolve(__dirname, 'app/demo-files')
        ],
        use: [ // 使用那些 Loader，有先后次序，从后往前执行
          'style-loader', // 直接使用 Loader 的名称
          {
            loader: 'css-loader',      
            options: { // 给 html-loader 传一些参数
            }
          }
        ]
      },
    ],
    noParse: [ // 不用解析和处理的模块
      /special-library\.js$/  // 用正则匹配
    ],
  },

  // 配置插件
  plugins: [
  ],

  // 配置寻找模块的规则
  resolve: { 
    modules: [ // 寻找模块的根目录，array 类型，默认以 node_modules 为根目录
      'node_modules',
      path.resolve(__dirname, 'app')
    ],
    extensions: ['.js', '.json', '.jsx', '.css'], // 模块的后缀名
    alias: { // 模块别名配置，用于映射模块
       // 把 'module' 映射 'new-module'，同样的 'module/path/file' 也会被映射成 'new-module/path/file'
      'module': 'new-module',
      // 使用结尾符号 $ 后，把 'only-module' 映射成 'new-module'，
      // 但是不像上面的，'module/path/file' 不会被映射成 'new-module/path/file'
      'only-module$': 'new-module', 
    },
    alias: [ // alias 还支持使用数组来更详细的配置
      {
        name: 'module', // 老的模块
        alias: 'new-module', // 新的模块
        // 是否是只映射模块，如果是 true 只有 'module' 会被映射，如果是 false 'module/inner/path' 也会被映射
        onlyModule: true, 
      }
    ],
    symlinks: true, // 是否跟随文件软链接去搜寻模块的路径
    descriptionFiles: ['package.json'], // 模块的描述文件
    mainFields: ['main'], // 模块的描述文件里的描述入口的文件的字段名称
    enforceExtension: false, // 是否强制导入语句必须要写明文件后缀
  },

  // 输出文件性能检查配置
  performance: { 
    hints: 'warning', // 有性能问题时输出警告
    hints: 'error', // 有性能问题时输出错误
    hints: false, // 关闭性能检查
    maxAssetSize: 200000, // 最大文件大小 (单位 bytes)
    maxEntrypointSize: 400000, // 最大入口文件大小 (单位 bytes)
    assetFilter: function(assetFilename) { // 过滤要检查的文件
      return assetFilename.endsWith('.css') || assetFilename.endsWith('.js');
    }
  },

  devtool: 'source-map', // 配置 source-map 类型

  context: __dirname, // Webpack 使用的根目录，string 类型必须是绝对路径

  // 配置输出代码的运行环境
  target: 'web', // 浏览器，默认
  target: 'webworker', // WebWorker
  target: 'node', // Node.js，使用 `require` 语句加载 Chunk 代码
  target: 'async-node', // Node.js，异步加载 Chunk 代码
  target: 'node-webkit', // nw.js
  target: 'electron-main', // electron, 主线程
  target: 'electron-renderer', // electron, 渲染线程

  externals: { // 使用来自 JavaScript 运行环境提供的全局变量
    jquery: 'jQuery'
  },

  stats: { // 控制台输出日志控制
    assets: true,
    colors: true,
    errors: true,
    errorDetails: true,
    hash: true,
  },

  devServer: { // DevServer 相关的配置
    proxy: { // 代理到后端服务接口
      '/api': 'http://localhost:3000'
    },
    contentBase: path.join(__dirname, 'public'), // 配置 DevServer HTTP 服务器的文件根目录
    compress: true, // 是否开启 gzip 压缩
    historyApiFallback: true, // 是否开发 HTML5 History API 网页
    hot: true, // 是否开启模块热替换功能
    https: false, // 是否开启 HTTPS 模式
    },

    profile: true, // 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳

    cache: false, // 是否启用缓存提升构建速度

    watch: true, // 是否开始
    watchOptions: { // 监听模式选项
    // 不监听的文件或文件夹，支持正则匹配。默认为空
    ignored: /node_modules/,
    // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高
    // 默认为300ms 
    aggregateTimeout: 300,
    // 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每隔1000毫秒询问一次
    poll: 1000
  },
}
```

# 计算机网络

## 动态主机配置协议（DHCP）

![image-20220428153019278](images\image-20220428153019278.png)

DHCP客户从DHCP服务器中获取IP地址的过程如下：

1. 客户端发生DHCP发现报文，因为客户端此时还没有分配IP地址所以是通过广播的形式将报文发送出去。
2. 具有处理进程的主机解析到了客户端广播出的报文，不具有处理进程的客户端忽略报文。
3. 服务器广播DHCP提供报文，在这之前是通过ARP确认要广播的IP地址没有被别的客户端占用，因为客户端此时还没有IP地址所以客户端也是广播发送。
4. 客户端收到提供报文然后广播DHCP请求报文，请求使用收到的IP地址。
5. 服务器确认IP地址没有别占用，然后广播DHCP确认报文；
6. 客户端收到确认报文后可以使用该IP地址；

DHCP客户端续约IP地址过程如下：

1. 客户端发送请求报文
2. 服务器可以有三种情况：发送确认报文、发送否认报文、不响应。
3. 客户端如果收到确认报文则续约成功，客户端收到否认博文则停止使用IP地址，重新发送发现报文请求。客户端如果为收到相应则再次发送请求报文；

DHCP客户端在IP地址使用有效期内随时可以发送释放报文来停止使用IP地址，并重新发送发现报文来获取。

## DNS

![image-20220428163834710](images\image-20220428163834710.png)

## DNS如何工作的

DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。

**我们通过一张图来看看它的查询过程吧**👇

![img](images/67.png)

这张图很生动的展示了DNS在本地DNS服务器是如何查询的，**一般向本地DNS服务器发送请求是递归查询的**

本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程👇

![img](images/68.png)

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/http/-HTTP相关总结.html#递归查询和迭代查询)递归查询和迭代查询

- 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
- 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。

所以一般而言，**本地服务器查询是递归查询**，而**本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程**。

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/http/-HTTP相关总结.html#dns缓存)DNS缓存

缓存也很好理解，在一个请求中，当某个DNS服务器收到一个DNS回答后，它能够回答中的信息缓存在本地存储器中。**返回的资源记录中的 TTL 代表了该条记录的缓存的时间。**

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/http/-HTTP相关总结.html#dns实现负载平衡)DNS实现负载平衡

它是如何实现负载均衡的呢？首先我们得清楚DNS 是可以用于在冗余的服务器上实现负载平衡。

**原因：**这是因为一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。

举个例子来说👇

- 当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合
- 在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。
- 以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。

### [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/http/-HTTP相关总结.html#总结)总结

- DNS域名系统，是应用层协议，运行UDP协议之上，使用端口43。
- 查询过程，本地查询是递归查询，依次通过浏览器缓存 `—>>` 本地hosts文件 `—>>` 本地DNS解析器 `—>>`本地DNS服务器 `—>>` 其他域名服务器请求。 接下来的过程就是迭代过程。
- 递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。

## [#](https://interview2.poetries.top/fe-blog-docs/blog-docs/http/-HTTP相关总结.html#dns-为什么使用-udp-协议作为传输层协议？)DNS 为什么使用 UDP 协议作为传输层协议？

**DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。**

- 为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。
- 大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。

